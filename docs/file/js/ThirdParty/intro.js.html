<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">js/ThirdParty/intro.js | cse110-w21-group28</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Necessary Packages for Development"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="cse110-w21-group28"><meta property="twitter:description" content="Necessary Packages for Development"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/Anshul-Birla/cse110-w21-group28"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#distraction">Distraction</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/Distraction/Distraction.js~Distraction.html">Distraction</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#misc">Misc</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-longBreakColors">longBreakColors</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-shortBreakColors">shortBreakColors</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-workModeColors">workModeColors</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-breakModeSound">breakModeSound</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-workModeSound">workModeSound</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-timeToString">timeToString</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-breakNames">breakNames</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-evenColor">evenColor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-headerColor">headerColor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-modalBGColor">modalBGColor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-modalFontColor">modalFontColor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-pageBGColor">pageBGColor</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-tableBG">tableBG</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-toothpaste">toothpaste</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#statistics">Statistics</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/Statistics/Statistics.js~Statistics.html">Statistics</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-classNames">classNames</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-storageItemNames">storageItemNames</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#timer">Timer</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/Timer/Timer.js~Timer.html">Timer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-buttonText">buttonText</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-longBreakMode">longBreakMode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-sessionStartName">sessionStartName</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-shortBreakMode">shortBreakMode</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-workMode">workMode</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#todolist">ToDoList</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/ToDoList/Task.js~Task.html">Task</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/ToDoList/ToDoList.js~ToDoList.html">ToDoList</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/js/ToDoList/TodoListDom.js~TodoListDom.html">TodoListDom</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-classNames">classNames</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-svg">svg</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-HTMLAttributes">HTMLAttributes</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-TaskStorage">TaskStorage</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">js/ThirdParty/intro.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/*!
 * Intro.js v3.3.1
 * https://introjs.com
 *
 * Copyright (C) 2012-2021 Afshin Mehrabani (@afshinmeh).
 * https://raw.githubusercontent.com/usablica/intro.js/master/license.md
 *
 * Date: Sun, 07 Feb 2021 12:38:48 GMT
 */

(function (global, factory) {
  typeof exports === &apos;object&apos; &amp;&amp; typeof module !== &apos;undefined&apos; ? module.exports = factory() :
  typeof define === &apos;function&apos; &amp;&amp; define.amd ? define(factory) :
  (global = global || self, global.introJs = factory());
}(this, (function () { &apos;use strict&apos;;

  function _typeof(obj) {
    &quot;@babel/helpers - typeof&quot;;

    if (typeof Symbol === &quot;function&quot; &amp;&amp; typeof Symbol.iterator === &quot;symbol&quot;) {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj &amp;&amp; typeof Symbol === &quot;function&quot; &amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? &quot;symbol&quot; : typeof obj;
      };
    }

    return _typeof(obj);
  }

  /**
   * Overwrites obj1&apos;s values with obj2&apos;s and adds obj2&apos;s if non existent in obj1
   * via: http://stackoverflow.com/questions/171251/how-can-i-merge-properties-of-two-javascript-objects-dynamically
   *
   * @param obj1
   * @param obj2
   * @returns obj3 a new object based on obj1 and obj2
   */
  function mergeOptions(obj1, obj2) {
    var obj3 = {};
    var attrname;

    for (attrname in obj1) {
      obj3[attrname] = obj1[attrname];
    }

    for (attrname in obj2) {
      obj3[attrname] = obj2[attrname];
    }

    return obj3;
  }

  /**
   * Mark any object with an incrementing number
   * used for keeping track of objects
   *
   * @param Object obj   Any object or DOM Element
   * @param String key
   * @return Object
   */
  var stamp = function () {
    var keys = {};
    return function stamp(obj) {
      var key = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : &quot;introjs-stamp&quot;;
      // each group increments from 0
      keys[key] = keys[key] || 0; // stamp only once per object

      if (obj[key] === undefined) {
        // increment key for each new object
        obj[key] = keys[key]++;
      }

      return obj[key];
    };
  }();

  /**
   * Iterates arrays
   *
   * @param {Array} arr
   * @param {Function} forEachFnc
   * @param {Function} completeFnc
   * @return {Null}
   */
  function forEach(arr, forEachFnc, completeFnc) {
    // in case arr is an empty query selector node list
    if (arr) {
      for (var i = 0, len = arr.length; i &lt; len; i++) {
        forEachFnc(arr[i], i);
      }
    }

    if (typeof completeFnc === &quot;function&quot;) {
      completeFnc();
    }
  }

  /**
   * DOMEvent Handles all DOM events
   *
   * methods:
   *
   * on - add event handler
   * off - remove event
   */

  var DOMEvent = function () {
    function DOMEvent() {
      var events_key = &quot;introjs_event&quot;;
      /**
       * Gets a unique ID for an event listener
       *
       * @param obj Object
       * @param type event type
       * @param listener Function
       * @param context Object
       * @return String
       */

      this._id = function (obj, type, listener, context) {
        return type + stamp(listener) + (context ? &quot;_&quot;.concat(stamp(context)) : &quot;&quot;);
      };
      /**
       * Adds event listener
       *
       * @param obj Object obj
       * @param type String
       * @param listener Function
       * @param context Object
       * @param useCapture Boolean
       * @return null
       */


      this.on = function (obj, type, listener, context, useCapture) {
        var id = this._id.apply(this, arguments);

        var handler = function handler(e) {
          return listener.call(context || obj, e || window.event);
        };

        if (&quot;addEventListener&quot; in obj) {
          obj.addEventListener(type, handler, useCapture);
        } else if (&quot;attachEvent&quot; in obj) {
          obj.attachEvent(&quot;on&quot;.concat(type), handler);
        }

        obj[events_key] = obj[events_key] || {};
        obj[events_key][id] = handler;
      };
      /**
       * Removes event listener
       *
       * @param obj Object
       * @param type String
       * @param listener Function
       * @param context Object
       * @param useCapture Boolean
       * @return null
       */


      this.off = function (obj, type, listener, context, useCapture) {
        var id = this._id.apply(this, arguments);

        var handler = obj[events_key] &amp;&amp; obj[events_key][id];

        if (!handler) {
          return;
        }

        if (&quot;removeEventListener&quot; in obj) {
          obj.removeEventListener(type, handler, useCapture);
        } else if (&quot;detachEvent&quot; in obj) {
          obj.detachEvent(&quot;on&quot;.concat(type), handler);
        }

        obj[events_key][id] = null;
      };
    }

    return new DOMEvent();
  }();

  var commonjsGlobal = typeof globalThis !== &apos;undefined&apos; ? globalThis : typeof window !== &apos;undefined&apos; ? window : typeof global !== &apos;undefined&apos; ? global : typeof self !== &apos;undefined&apos; ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var check = function (it) {
    return it &amp;&amp; it.Math == Math &amp;&amp; it;
  };

  // https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
  var global_1 =
    // eslint-disable-next-line no-undef
    check(typeof globalThis == &apos;object&apos; &amp;&amp; globalThis) ||
    check(typeof window == &apos;object&apos; &amp;&amp; window) ||
    check(typeof self == &apos;object&apos; &amp;&amp; self) ||
    check(typeof commonjsGlobal == &apos;object&apos; &amp;&amp; commonjsGlobal) ||
    // eslint-disable-next-line no-new-func
    (function () { return this; })() || Function(&apos;return this&apos;)();

  var fails = function (exec) {
    try {
      return !!exec();
    } catch (error) {
      return true;
    }
  };

  // Detect IE8&apos;s incomplete defineProperty implementation
  var descriptors = !fails(function () {
    return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
  });

  var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

  // Nashorn ~ JDK8 bug
  var NASHORN_BUG = getOwnPropertyDescriptor &amp;&amp; !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

  // `Object.prototype.propertyIsEnumerable` method implementation
  // https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
  var f = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor = getOwnPropertyDescriptor(this, V);
    return !!descriptor &amp;&amp; descriptor.enumerable;
  } : nativePropertyIsEnumerable;

  var objectPropertyIsEnumerable = {
  	f: f
  };

  var createPropertyDescriptor = function (bitmap, value) {
    return {
      enumerable: !(bitmap &amp; 1),
      configurable: !(bitmap &amp; 2),
      writable: !(bitmap &amp; 4),
      value: value
    };
  };

  var toString = {}.toString;

  var classofRaw = function (it) {
    return toString.call(it).slice(8, -1);
  };

  var split = &apos;&apos;.split;

  // fallback for non-array-like ES3 and non-enumerable old V8 strings
  var indexedObject = fails(function () {
    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
    // eslint-disable-next-line no-prototype-builtins
    return !Object(&apos;z&apos;).propertyIsEnumerable(0);
  }) ? function (it) {
    return classofRaw(it) == &apos;String&apos; ? split.call(it, &apos;&apos;) : Object(it);
  } : Object;

  // `RequireObjectCoercible` abstract operation
  // https://tc39.es/ecma262/#sec-requireobjectcoercible
  var requireObjectCoercible = function (it) {
    if (it == undefined) throw TypeError(&quot;Can&apos;t call method on &quot; + it);
    return it;
  };

  // toObject with fallback for non-array-like ES3 strings



  var toIndexedObject = function (it) {
    return indexedObject(requireObjectCoercible(it));
  };

  var isObject = function (it) {
    return typeof it === &apos;object&apos; ? it !== null : typeof it === &apos;function&apos;;
  };

  // `ToPrimitive` abstract operation
  // https://tc39.es/ecma262/#sec-toprimitive
  // instead of the ES6 spec version, we didn&apos;t implement @@toPrimitive case
  // and the second argument - flag - preferred type is a string
  var toPrimitive = function (input, PREFERRED_STRING) {
    if (!isObject(input)) return input;
    var fn, val;
    if (PREFERRED_STRING &amp;&amp; typeof (fn = input.toString) == &apos;function&apos; &amp;&amp; !isObject(val = fn.call(input))) return val;
    if (typeof (fn = input.valueOf) == &apos;function&apos; &amp;&amp; !isObject(val = fn.call(input))) return val;
    if (!PREFERRED_STRING &amp;&amp; typeof (fn = input.toString) == &apos;function&apos; &amp;&amp; !isObject(val = fn.call(input))) return val;
    throw TypeError(&quot;Can&apos;t convert object to primitive value&quot;);
  };

  var hasOwnProperty = {}.hasOwnProperty;

  var has = function (it, key) {
    return hasOwnProperty.call(it, key);
  };

  var document$1 = global_1.document;
  // typeof document.createElement is &apos;object&apos; in old IE
  var EXISTS = isObject(document$1) &amp;&amp; isObject(document$1.createElement);

  var documentCreateElement = function (it) {
    return EXISTS ? document$1.createElement(it) : {};
  };

  // Thank&apos;s IE8 for his funny defineProperty
  var ie8DomDefine = !descriptors &amp;&amp; !fails(function () {
    return Object.defineProperty(documentCreateElement(&apos;div&apos;), &apos;a&apos;, {
      get: function () { return 7; }
    }).a != 7;
  });

  var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
  var f$1 = descriptors ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject(O);
    P = toPrimitive(P, true);
    if (ie8DomDefine) try {
      return nativeGetOwnPropertyDescriptor(O, P);
    } catch (error) { /* empty */ }
    if (has(O, P)) return createPropertyDescriptor(!objectPropertyIsEnumerable.f.call(O, P), O[P]);
  };

  var objectGetOwnPropertyDescriptor = {
  	f: f$1
  };

  var anObject = function (it) {
    if (!isObject(it)) {
      throw TypeError(String(it) + &apos; is not an object&apos;);
    } return it;
  };

  var nativeDefineProperty = Object.defineProperty;

  // `Object.defineProperty` method
  // https://tc39.es/ecma262/#sec-object.defineproperty
  var f$2 = descriptors ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
    anObject(O);
    P = toPrimitive(P, true);
    anObject(Attributes);
    if (ie8DomDefine) try {
      return nativeDefineProperty(O, P, Attributes);
    } catch (error) { /* empty */ }
    if (&apos;get&apos; in Attributes || &apos;set&apos; in Attributes) throw TypeError(&apos;Accessors not supported&apos;);
    if (&apos;value&apos; in Attributes) O[P] = Attributes.value;
    return O;
  };

  var objectDefineProperty = {
  	f: f$2
  };

  var createNonEnumerableProperty = descriptors ? function (object, key, value) {
    return objectDefineProperty.f(object, key, createPropertyDescriptor(1, value));
  } : function (object, key, value) {
    object[key] = value;
    return object;
  };

  var setGlobal = function (key, value) {
    try {
      createNonEnumerableProperty(global_1, key, value);
    } catch (error) {
      global_1[key] = value;
    } return value;
  };

  var SHARED = &apos;__core-js_shared__&apos;;
  var store = global_1[SHARED] || setGlobal(SHARED, {});

  var sharedStore = store;

  var functionToString = Function.toString;

  // this helper broken in `3.4.1-3.4.4`, so we can&apos;t use `shared` helper
  if (typeof sharedStore.inspectSource != &apos;function&apos;) {
    sharedStore.inspectSource = function (it) {
      return functionToString.call(it);
    };
  }

  var inspectSource = sharedStore.inspectSource;

  var WeakMap = global_1.WeakMap;

  var nativeWeakMap = typeof WeakMap === &apos;function&apos; &amp;&amp; /native code/.test(inspectSource(WeakMap));

  var shared = createCommonjsModule(function (module) {
  (module.exports = function (key, value) {
    return sharedStore[key] || (sharedStore[key] = value !== undefined ? value : {});
  })(&apos;versions&apos;, []).push({
    version: &apos;3.8.3&apos;,
    mode:  &apos;global&apos;,
    copyright: &apos;&#xA9; 2021 Denis Pushkarev (zloirock.ru)&apos;
  });
  });

  var id = 0;
  var postfix = Math.random();

  var uid = function (key) {
    return &apos;Symbol(&apos; + String(key === undefined ? &apos;&apos; : key) + &apos;)_&apos; + (++id + postfix).toString(36);
  };

  var keys = shared(&apos;keys&apos;);

  var sharedKey = function (key) {
    return keys[key] || (keys[key] = uid(key));
  };

  var hiddenKeys = {};

  var WeakMap$1 = global_1.WeakMap;
  var set, get, has$1;

  var enforce = function (it) {
    return has$1(it) ? get(it) : set(it, {});
  };

  var getterFor = function (TYPE) {
    return function (it) {
      var state;
      if (!isObject(it) || (state = get(it)).type !== TYPE) {
        throw TypeError(&apos;Incompatible receiver, &apos; + TYPE + &apos; required&apos;);
      } return state;
    };
  };

  if (nativeWeakMap) {
    var store$1 = sharedStore.state || (sharedStore.state = new WeakMap$1());
    var wmget = store$1.get;
    var wmhas = store$1.has;
    var wmset = store$1.set;
    set = function (it, metadata) {
      metadata.facade = it;
      wmset.call(store$1, it, metadata);
      return metadata;
    };
    get = function (it) {
      return wmget.call(store$1, it) || {};
    };
    has$1 = function (it) {
      return wmhas.call(store$1, it);
    };
  } else {
    var STATE = sharedKey(&apos;state&apos;);
    hiddenKeys[STATE] = true;
    set = function (it, metadata) {
      metadata.facade = it;
      createNonEnumerableProperty(it, STATE, metadata);
      return metadata;
    };
    get = function (it) {
      return has(it, STATE) ? it[STATE] : {};
    };
    has$1 = function (it) {
      return has(it, STATE);
    };
  }

  var internalState = {
    set: set,
    get: get,
    has: has$1,
    enforce: enforce,
    getterFor: getterFor
  };

  var redefine = createCommonjsModule(function (module) {
  var getInternalState = internalState.get;
  var enforceInternalState = internalState.enforce;
  var TEMPLATE = String(String).split(&apos;String&apos;);

  (module.exports = function (O, key, value, options) {
    var unsafe = options ? !!options.unsafe : false;
    var simple = options ? !!options.enumerable : false;
    var noTargetGet = options ? !!options.noTargetGet : false;
    var state;
    if (typeof value == &apos;function&apos;) {
      if (typeof key == &apos;string&apos; &amp;&amp; !has(value, &apos;name&apos;)) {
        createNonEnumerableProperty(value, &apos;name&apos;, key);
      }
      state = enforceInternalState(value);
      if (!state.source) {
        state.source = TEMPLATE.join(typeof key == &apos;string&apos; ? key : &apos;&apos;);
      }
    }
    if (O === global_1) {
      if (simple) O[key] = value;
      else setGlobal(key, value);
      return;
    } else if (!unsafe) {
      delete O[key];
    } else if (!noTargetGet &amp;&amp; O[key]) {
      simple = true;
    }
    if (simple) O[key] = value;
    else createNonEnumerableProperty(O, key, value);
  // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
  })(Function.prototype, &apos;toString&apos;, function toString() {
    return typeof this == &apos;function&apos; &amp;&amp; getInternalState(this).source || inspectSource(this);
  });
  });

  var path = global_1;

  var aFunction = function (variable) {
    return typeof variable == &apos;function&apos; ? variable : undefined;
  };

  var getBuiltIn = function (namespace, method) {
    return arguments.length &lt; 2 ? aFunction(path[namespace]) || aFunction(global_1[namespace])
      : path[namespace] &amp;&amp; path[namespace][method] || global_1[namespace] &amp;&amp; global_1[namespace][method];
  };

  var ceil = Math.ceil;
  var floor = Math.floor;

  // `ToInteger` abstract operation
  // https://tc39.es/ecma262/#sec-tointeger
  var toInteger = function (argument) {
    return isNaN(argument = +argument) ? 0 : (argument &gt; 0 ? floor : ceil)(argument);
  };

  var min = Math.min;

  // `ToLength` abstract operation
  // https://tc39.es/ecma262/#sec-tolength
  var toLength = function (argument) {
    return argument &gt; 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
  };

  var max = Math.max;
  var min$1 = Math.min;

  // Helper for a popular repeating case of the spec:
  // Let integer be ? ToInteger(index).
  // If integer &lt; 0, let result be max((length + integer), 0); else let result be min(integer, length).
  var toAbsoluteIndex = function (index, length) {
    var integer = toInteger(index);
    return integer &lt; 0 ? max(integer + length, 0) : min$1(integer, length);
  };

  // `Array.prototype.{ indexOf, includes }` methods implementation
  var createMethod = function (IS_INCLUDES) {
    return function ($this, el, fromIndex) {
      var O = toIndexedObject($this);
      var length = toLength(O.length);
      var index = toAbsoluteIndex(fromIndex, length);
      var value;
      // Array#includes uses SameValueZero equality algorithm
      // eslint-disable-next-line no-self-compare
      if (IS_INCLUDES &amp;&amp; el != el) while (length &gt; index) {
        value = O[index++];
        // eslint-disable-next-line no-self-compare
        if (value != value) return true;
      // Array#indexOf ignores holes, Array#includes - not
      } else for (;length &gt; index; index++) {
        if ((IS_INCLUDES || index in O) &amp;&amp; O[index] === el) return IS_INCLUDES || index || 0;
      } return !IS_INCLUDES &amp;&amp; -1;
    };
  };

  var arrayIncludes = {
    // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes
    includes: createMethod(true),
    // `Array.prototype.indexOf` method
    // https://tc39.es/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod(false)
  };

  var indexOf = arrayIncludes.indexOf;


  var objectKeysInternal = function (object, names) {
    var O = toIndexedObject(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) !has(hiddenKeys, key) &amp;&amp; has(O, key) &amp;&amp; result.push(key);
    // Don&apos;t enum bug &amp; hidden keys
    while (names.length &gt; i) if (has(O, key = names[i++])) {
      ~indexOf(result, key) || result.push(key);
    }
    return result;
  };

  // IE8- don&apos;t enum bug keys
  var enumBugKeys = [
    &apos;constructor&apos;,
    &apos;hasOwnProperty&apos;,
    &apos;isPrototypeOf&apos;,
    &apos;propertyIsEnumerable&apos;,
    &apos;toLocaleString&apos;,
    &apos;toString&apos;,
    &apos;valueOf&apos;
  ];

  var hiddenKeys$1 = enumBugKeys.concat(&apos;length&apos;, &apos;prototype&apos;);

  // `Object.getOwnPropertyNames` method
  // https://tc39.es/ecma262/#sec-object.getownpropertynames
  var f$3 = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return objectKeysInternal(O, hiddenKeys$1);
  };

  var objectGetOwnPropertyNames = {
  	f: f$3
  };

  var f$4 = Object.getOwnPropertySymbols;

  var objectGetOwnPropertySymbols = {
  	f: f$4
  };

  // all object keys, includes non-enumerable and symbols
  var ownKeys = getBuiltIn(&apos;Reflect&apos;, &apos;ownKeys&apos;) || function ownKeys(it) {
    var keys = objectGetOwnPropertyNames.f(anObject(it));
    var getOwnPropertySymbols = objectGetOwnPropertySymbols.f;
    return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
  };

  var copyConstructorProperties = function (target, source) {
    var keys = ownKeys(source);
    var defineProperty = objectDefineProperty.f;
    var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
    for (var i = 0; i &lt; keys.length; i++) {
      var key = keys[i];
      if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
  };

  var replacement = /#|\.prototype\./;

  var isForced = function (feature, detection) {
    var value = data[normalize(feature)];
    return value == POLYFILL ? true
      : value == NATIVE ? false
      : typeof detection == &apos;function&apos; ? fails(detection)
      : !!detection;
  };

  var normalize = isForced.normalize = function (string) {
    return String(string).replace(replacement, &apos;.&apos;).toLowerCase();
  };

  var data = isForced.data = {};
  var NATIVE = isForced.NATIVE = &apos;N&apos;;
  var POLYFILL = isForced.POLYFILL = &apos;P&apos;;

  var isForced_1 = isForced;

  var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;






  /*
    options.target      - name of the target object
    options.global      - target is the global object
    options.stat        - export as static methods of target
    options.proto       - export as prototype methods of target
    options.real        - real prototype method for the `pure` version
    options.forced      - export even if the native feature is available
    options.bind        - bind methods to the target, required for the `pure` version
    options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
    options.unsafe      - use the simple assignment of property instead of delete + defineProperty
    options.sham        - add a flag to not completely full polyfills
    options.enumerable  - export as enumerable property
    options.noTargetGet - prevent calling a getter on target
  */
  var _export = function (options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED, target, key, targetProperty, sourceProperty, descriptor;
    if (GLOBAL) {
      target = global_1;
    } else if (STATIC) {
      target = global_1[TARGET] || setGlobal(TARGET, {});
    } else {
      target = (global_1[TARGET] || {}).prototype;
    }
    if (target) for (key in source) {
      sourceProperty = source[key];
      if (options.noTargetGet) {
        descriptor = getOwnPropertyDescriptor$1(target, key);
        targetProperty = descriptor &amp;&amp; descriptor.value;
      } else targetProperty = target[key];
      FORCED = isForced_1(GLOBAL ? key : TARGET + (STATIC ? &apos;.&apos; : &apos;#&apos;) + key, options.forced);
      // contained in target
      if (!FORCED &amp;&amp; targetProperty !== undefined) {
        if (typeof sourceProperty === typeof targetProperty) continue;
        copyConstructorProperties(sourceProperty, targetProperty);
      }
      // add a flag to not completely full polyfills
      if (options.sham || (targetProperty &amp;&amp; targetProperty.sham)) {
        createNonEnumerableProperty(sourceProperty, &apos;sham&apos;, true);
      }
      // extend global
      redefine(target, key, sourceProperty, options);
    }
  };

  // `RegExp.prototype.flags` getter implementation
  // https://tc39.es/ecma262/#sec-get-regexp.prototype.flags
  var regexpFlags = function () {
    var that = anObject(this);
    var result = &apos;&apos;;
    if (that.global) result += &apos;g&apos;;
    if (that.ignoreCase) result += &apos;i&apos;;
    if (that.multiline) result += &apos;m&apos;;
    if (that.dotAll) result += &apos;s&apos;;
    if (that.unicode) result += &apos;u&apos;;
    if (that.sticky) result += &apos;y&apos;;
    return result;
  };

  // babel-minify transpiles RegExp(&apos;a&apos;, &apos;y&apos;) -&gt; /a/y and it causes SyntaxError,
  // so we use an intermediate function.
  function RE(s, f) {
    return RegExp(s, f);
  }

  var UNSUPPORTED_Y = fails(function () {
    // babel-minify transpiles RegExp(&apos;a&apos;, &apos;y&apos;) -&gt; /a/y and it causes SyntaxError
    var re = RE(&apos;a&apos;, &apos;y&apos;);
    re.lastIndex = 2;
    return re.exec(&apos;abcd&apos;) != null;
  });

  var BROKEN_CARET = fails(function () {
    // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
    var re = RE(&apos;^r&apos;, &apos;gy&apos;);
    re.lastIndex = 2;
    return re.exec(&apos;str&apos;) != null;
  });

  var regexpStickyHelpers = {
  	UNSUPPORTED_Y: UNSUPPORTED_Y,
  	BROKEN_CARET: BROKEN_CARET
  };

  var nativeExec = RegExp.prototype.exec;
  // This always refers to the native implementation, because the
  // String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
  // which loads this file before patching the method.
  var nativeReplace = String.prototype.replace;

  var patchedExec = nativeExec;

  var UPDATES_LAST_INDEX_WRONG = (function () {
    var re1 = /a/;
    var re2 = /b*/g;
    nativeExec.call(re1, &apos;a&apos;);
    nativeExec.call(re2, &apos;a&apos;);
    return re1.lastIndex !== 0 || re2.lastIndex !== 0;
  })();

  var UNSUPPORTED_Y$1 = regexpStickyHelpers.UNSUPPORTED_Y || regexpStickyHelpers.BROKEN_CARET;

  // nonparticipating capturing group, copied from es5-shim&apos;s String#split patch.
  var NPCG_INCLUDED = /()??/.exec(&apos;&apos;)[1] !== undefined;

  var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y$1;

  if (PATCH) {
    patchedExec = function exec(str) {
      var re = this;
      var lastIndex, reCopy, match, i;
      var sticky = UNSUPPORTED_Y$1 &amp;&amp; re.sticky;
      var flags = regexpFlags.call(re);
      var source = re.source;
      var charsAdded = 0;
      var strCopy = str;

      if (sticky) {
        flags = flags.replace(&apos;y&apos;, &apos;&apos;);
        if (flags.indexOf(&apos;g&apos;) === -1) {
          flags += &apos;g&apos;;
        }

        strCopy = String(str).slice(re.lastIndex);
        // Support anchored sticky behavior.
        if (re.lastIndex &gt; 0 &amp;&amp; (!re.multiline || re.multiline &amp;&amp; str[re.lastIndex - 1] !== &apos;\n&apos;)) {
          source = &apos;(?: &apos; + source + &apos;)&apos;;
          strCopy = &apos; &apos; + strCopy;
          charsAdded++;
        }
        // ^(? + rx + ) is needed, in combination with some str slicing, to
        // simulate the &apos;y&apos; flag.
        reCopy = new RegExp(&apos;^(?:&apos; + source + &apos;)&apos;, flags);
      }

      if (NPCG_INCLUDED) {
        reCopy = new RegExp(&apos;^&apos; + source + &apos;$(?!\\s)&apos;, flags);
      }
      if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

      match = nativeExec.call(sticky ? reCopy : re, strCopy);

      if (sticky) {
        if (match) {
          match.input = match.input.slice(charsAdded);
          match[0] = match[0].slice(charsAdded);
          match.index = re.lastIndex;
          re.lastIndex += match[0].length;
        } else re.lastIndex = 0;
      } else if (UPDATES_LAST_INDEX_WRONG &amp;&amp; match) {
        re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
      }
      if (NPCG_INCLUDED &amp;&amp; match &amp;&amp; match.length &gt; 1) {
        // Fix browsers whose `exec` methods don&apos;t consistently return `undefined`
        // for NPCG, like IE8. NOTE: This doesn&apos; work for /(.?)?/
        nativeReplace.call(match[0], reCopy, function () {
          for (i = 1; i &lt; arguments.length - 2; i++) {
            if (arguments[i] === undefined) match[i] = undefined;
          }
        });
      }

      return match;
    };
  }

  var regexpExec = patchedExec;

  // `RegExp.prototype.exec` method
  // https://tc39.es/ecma262/#sec-regexp.prototype.exec
  _export({ target: &apos;RegExp&apos;, proto: true, forced: /./.exec !== regexpExec }, {
    exec: regexpExec
  });

  var nativeSymbol = !!Object.getOwnPropertySymbols &amp;&amp; !fails(function () {
    // Chrome 38 Symbol has incorrect toString conversion
    // eslint-disable-next-line no-undef
    return !String(Symbol());
  });

  var useSymbolAsUid = nativeSymbol
    // eslint-disable-next-line no-undef
    &amp;&amp; !Symbol.sham
    // eslint-disable-next-line no-undef
    &amp;&amp; typeof Symbol.iterator == &apos;symbol&apos;;

  var WellKnownSymbolsStore = shared(&apos;wks&apos;);
  var Symbol$1 = global_1.Symbol;
  var createWellKnownSymbol = useSymbolAsUid ? Symbol$1 : Symbol$1 &amp;&amp; Symbol$1.withoutSetter || uid;

  var wellKnownSymbol = function (name) {
    if (!has(WellKnownSymbolsStore, name)) {
      if (nativeSymbol &amp;&amp; has(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];
      else WellKnownSymbolsStore[name] = createWellKnownSymbol(&apos;Symbol.&apos; + name);
    } return WellKnownSymbolsStore[name];
  };

  // TODO: Remove from `core-js@4` since it&apos;s moved to entry points







  var SPECIES = wellKnownSymbol(&apos;species&apos;);

  var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
    // #replace needs built-in support for named groups.
    // #match works fine because it just return the exec results, even if it has
    // a &quot;grops&quot; property.
    var re = /./;
    re.exec = function () {
      var result = [];
      result.groups = { a: &apos;7&apos; };
      return result;
    };
    return &apos;&apos;.replace(re, &apos;$&lt;a&gt;&apos;) !== &apos;7&apos;;
  });

  // IE &lt;= 11 replaces $0 with the whole match, as if it was $&amp;
  // https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
  var REPLACE_KEEPS_$0 = (function () {
    return &apos;a&apos;.replace(/./, &apos;$0&apos;) === &apos;$0&apos;;
  })();

  var REPLACE = wellKnownSymbol(&apos;replace&apos;);
  // Safari &lt;= 13.0.3(?) substitutes nth capture where n&gt;m with an empty string
  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
    if (/./[REPLACE]) {
      return /./[REPLACE](&apos;a&apos;, &apos;$0&apos;) === &apos;&apos;;
    }
    return false;
  })();

  // Chrome 51 has a buggy &quot;split&quot; implementation when RegExp#exec !== nativeExec
  // Weex JS has frozen built-in prototypes, so use try / catch wrapper
  var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
    var re = /(?:)/;
    var originalExec = re.exec;
    re.exec = function () { return originalExec.apply(this, arguments); };
    var result = &apos;ab&apos;.split(re);
    return result.length !== 2 || result[0] !== &apos;a&apos; || result[1] !== &apos;b&apos;;
  });

  var fixRegexpWellKnownSymbolLogic = function (KEY, length, exec, sham) {
    var SYMBOL = wellKnownSymbol(KEY);

    var DELEGATES_TO_SYMBOL = !fails(function () {
      // String methods call symbol-named RegEp methods
      var O = {};
      O[SYMBOL] = function () { return 7; };
      return &apos;&apos;[KEY](O) != 7;
    });

    var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL &amp;&amp; !fails(function () {
      // Symbol-named RegExp methods call .exec
      var execCalled = false;
      var re = /a/;

      if (KEY === &apos;split&apos;) {
        // We can&apos;t use real regex here since it causes deoptimization
        // and serious performance degradation in V8
        // https://github.com/zloirock/core-js/issues/306
        re = {};
        // RegExp[@@split] doesn&apos;t call the regex&apos;s exec method, but first creates
        // a new one. We need to return the patched regex when creating the new one.
        re.constructor = {};
        re.constructor[SPECIES] = function () { return re; };
        re.flags = &apos;&apos;;
        re[SYMBOL] = /./[SYMBOL];
      }

      re.exec = function () { execCalled = true; return null; };

      re[SYMBOL](&apos;&apos;);
      return !execCalled;
    });

    if (
      !DELEGATES_TO_SYMBOL ||
      !DELEGATES_TO_EXEC ||
      (KEY === &apos;replace&apos; &amp;&amp; !(
        REPLACE_SUPPORTS_NAMED_GROUPS &amp;&amp;
        REPLACE_KEEPS_$0 &amp;&amp;
        !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
      )) ||
      (KEY === &apos;split&apos; &amp;&amp; !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
    ) {
      var nativeRegExpMethod = /./[SYMBOL];
      var methods = exec(SYMBOL, &apos;&apos;[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL &amp;&amp; !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }, {
        REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
        REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
      });
      var stringMethod = methods[0];
      var regexMethod = methods[1];

      redefine(String.prototype, KEY, stringMethod);
      redefine(RegExp.prototype, SYMBOL, length == 2
        // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
        // 21.2.5.11 RegExp.prototype[@@split](string, limit)
        ? function (string, arg) { return regexMethod.call(string, this, arg); }
        // 21.2.5.6 RegExp.prototype[@@match](string)
        // 21.2.5.9 RegExp.prototype[@@search](string)
        : function (string) { return regexMethod.call(string, this); }
      );
    }

    if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], &apos;sham&apos;, true);
  };

  // `String.prototype.{ codePointAt, at }` methods implementation
  var createMethod$1 = function (CONVERT_TO_STRING) {
    return function ($this, pos) {
      var S = String(requireObjectCoercible($this));
      var position = toInteger(pos);
      var size = S.length;
      var first, second;
      if (position &lt; 0 || position &gt;= size) return CONVERT_TO_STRING ? &apos;&apos; : undefined;
      first = S.charCodeAt(position);
      return first &lt; 0xD800 || first &gt; 0xDBFF || position + 1 === size
        || (second = S.charCodeAt(position + 1)) &lt; 0xDC00 || second &gt; 0xDFFF
          ? CONVERT_TO_STRING ? S.charAt(position) : first
          : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 &lt;&lt; 10) + (second - 0xDC00) + 0x10000;
    };
  };

  var stringMultibyte = {
    // `String.prototype.codePointAt` method
    // https://tc39.es/ecma262/#sec-string.prototype.codepointat
    codeAt: createMethod$1(false),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: createMethod$1(true)
  };

  var charAt = stringMultibyte.charAt;

  // `AdvanceStringIndex` abstract operation
  // https://tc39.es/ecma262/#sec-advancestringindex
  var advanceStringIndex = function (S, index, unicode) {
    return index + (unicode ? charAt(S, index).length : 1);
  };

  // `RegExpExec` abstract operation
  // https://tc39.es/ecma262/#sec-regexpexec
  var regexpExecAbstract = function (R, S) {
    var exec = R.exec;
    if (typeof exec === &apos;function&apos;) {
      var result = exec.call(R, S);
      if (typeof result !== &apos;object&apos;) {
        throw TypeError(&apos;RegExp exec method returned something other than an Object or null&apos;);
      }
      return result;
    }

    if (classofRaw(R) !== &apos;RegExp&apos;) {
      throw TypeError(&apos;RegExp#exec called on incompatible receiver&apos;);
    }

    return regexpExec.call(R, S);
  };

  // @@match logic
  fixRegexpWellKnownSymbolLogic(&apos;match&apos;, 1, function (MATCH, nativeMatch, maybeCallNative) {
    return [
      // `String.prototype.match` method
      // https://tc39.es/ecma262/#sec-string.prototype.match
      function match(regexp) {
        var O = requireObjectCoercible(this);
        var matcher = regexp == undefined ? undefined : regexp[MATCH];
        return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
      },
      // `RegExp.prototype[@@match]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@match
      function (regexp) {
        var res = maybeCallNative(nativeMatch, regexp, this);
        if (res.done) return res.value;

        var rx = anObject(regexp);
        var S = String(this);

        if (!rx.global) return regexpExecAbstract(rx, S);

        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
        var A = [];
        var n = 0;
        var result;
        while ((result = regexpExecAbstract(rx, S)) !== null) {
          var matchStr = String(result[0]);
          A[n] = matchStr;
          if (matchStr === &apos;&apos;) rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
          n++;
        }
        return n === 0 ? null : A;
      }
    ];
  });

  // `IsArray` abstract operation
  // https://tc39.es/ecma262/#sec-isarray
  var isArray = Array.isArray || function isArray(arg) {
    return classofRaw(arg) == &apos;Array&apos;;
  };

  // `ToObject` abstract operation
  // https://tc39.es/ecma262/#sec-toobject
  var toObject = function (argument) {
    return Object(requireObjectCoercible(argument));
  };

  var createProperty = function (object, key, value) {
    var propertyKey = toPrimitive(key);
    if (propertyKey in object) objectDefineProperty.f(object, propertyKey, createPropertyDescriptor(0, value));
    else object[propertyKey] = value;
  };

  var SPECIES$1 = wellKnownSymbol(&apos;species&apos;);

  // `ArraySpeciesCreate` abstract operation
  // https://tc39.es/ecma262/#sec-arrayspeciescreate
  var arraySpeciesCreate = function (originalArray, length) {
    var C;
    if (isArray(originalArray)) {
      C = originalArray.constructor;
      // cross-realm fallback
      if (typeof C == &apos;function&apos; &amp;&amp; (C === Array || isArray(C.prototype))) C = undefined;
      else if (isObject(C)) {
        C = C[SPECIES$1];
        if (C === null) C = undefined;
      }
    } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
  };

  var engineUserAgent = getBuiltIn(&apos;navigator&apos;, &apos;userAgent&apos;) || &apos;&apos;;

  var process = global_1.process;
  var versions = process &amp;&amp; process.versions;
  var v8 = versions &amp;&amp; versions.v8;
  var match, version;

  if (v8) {
    match = v8.split(&apos;.&apos;);
    version = match[0] + match[1];
  } else if (engineUserAgent) {
    match = engineUserAgent.match(/Edge\/(\d+)/);
    if (!match || match[1] &gt;= 74) {
      match = engineUserAgent.match(/Chrome\/(\d+)/);
      if (match) version = match[1];
    }
  }

  var engineV8Version = version &amp;&amp; +version;

  var SPECIES$2 = wellKnownSymbol(&apos;species&apos;);

  var arrayMethodHasSpeciesSupport = function (METHOD_NAME) {
    // We can&apos;t use this feature detection in V8 since it causes
    // deoptimization and serious performance degradation
    // https://github.com/zloirock/core-js/issues/677
    return engineV8Version &gt;= 51 || !fails(function () {
      var array = [];
      var constructor = array.constructor = {};
      constructor[SPECIES$2] = function () {
        return { foo: 1 };
      };
      return array[METHOD_NAME](Boolean).foo !== 1;
    });
  };

  var IS_CONCAT_SPREADABLE = wellKnownSymbol(&apos;isConcatSpreadable&apos;);
  var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
  var MAXIMUM_ALLOWED_INDEX_EXCEEDED = &apos;Maximum allowed index exceeded&apos;;

  // We can&apos;t use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/679
  var IS_CONCAT_SPREADABLE_SUPPORT = engineV8Version &gt;= 51 || !fails(function () {
    var array = [];
    array[IS_CONCAT_SPREADABLE] = false;
    return array.concat()[0] !== array;
  });

  var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport(&apos;concat&apos;);

  var isConcatSpreadable = function (O) {
    if (!isObject(O)) return false;
    var spreadable = O[IS_CONCAT_SPREADABLE];
    return spreadable !== undefined ? !!spreadable : isArray(O);
  };

  var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

  // `Array.prototype.concat` method
  // https://tc39.es/ecma262/#sec-array.prototype.concat
  // with adding support of @@isConcatSpreadable and @@species
  _export({ target: &apos;Array&apos;, proto: true, forced: FORCED }, {
    concat: function concat(arg) { // eslint-disable-line no-unused-vars
      var O = toObject(this);
      var A = arraySpeciesCreate(O, 0);
      var n = 0;
      var i, k, length, len, E;
      for (i = -1, length = arguments.length; i &lt; length; i++) {
        E = i === -1 ? O : arguments[i];
        if (isConcatSpreadable(E)) {
          len = toLength(E.length);
          if (n + len &gt; MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
          for (k = 0; k &lt; len; k++, n++) if (k in E) createProperty(A, n, E[k]);
        } else {
          if (n &gt;= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
          createProperty(A, n++, E);
        }
      }
      A.length = n;
      return A;
    }
  });

  var TO_STRING_TAG = wellKnownSymbol(&apos;toStringTag&apos;);
  var test = {};

  test[TO_STRING_TAG] = &apos;z&apos;;

  var toStringTagSupport = String(test) === &apos;[object z]&apos;;

  var TO_STRING_TAG$1 = wellKnownSymbol(&apos;toStringTag&apos;);
  // ES3 wrong here
  var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == &apos;Arguments&apos;;

  // fallback for IE11 Script Access Denied error
  var tryGet = function (it, key) {
    try {
      return it[key];
    } catch (error) { /* empty */ }
  };

  // getting tag from ES6+ `Object.prototype.toString`
  var classof = toStringTagSupport ? classofRaw : function (it) {
    var O, tag, result;
    return it === undefined ? &apos;Undefined&apos; : it === null ? &apos;Null&apos;
      // @@toStringTag case
      : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG$1)) == &apos;string&apos; ? tag
      // builtinTag case
      : CORRECT_ARGUMENTS ? classofRaw(O)
      // ES3 arguments fallback
      : (result = classofRaw(O)) == &apos;Object&apos; &amp;&amp; typeof O.callee == &apos;function&apos; ? &apos;Arguments&apos; : result;
  };

  // `Object.prototype.toString` method implementation
  // https://tc39.es/ecma262/#sec-object.prototype.tostring
  var objectToString = toStringTagSupport ? {}.toString : function toString() {
    return &apos;[object &apos; + classof(this) + &apos;]&apos;;
  };

  // `Object.prototype.toString` method
  // https://tc39.es/ecma262/#sec-object.prototype.tostring
  if (!toStringTagSupport) {
    redefine(Object.prototype, &apos;toString&apos;, objectToString, { unsafe: true });
  }

  var TO_STRING = &apos;toString&apos;;
  var RegExpPrototype = RegExp.prototype;
  var nativeToString = RegExpPrototype[TO_STRING];

  var NOT_GENERIC = fails(function () { return nativeToString.call({ source: &apos;a&apos;, flags: &apos;b&apos; }) != &apos;/a/b&apos;; });
  // FF44- RegExp#toString has a wrong name
  var INCORRECT_NAME = nativeToString.name != TO_STRING;

  // `RegExp.prototype.toString` method
  // https://tc39.es/ecma262/#sec-regexp.prototype.tostring
  if (NOT_GENERIC || INCORRECT_NAME) {
    redefine(RegExp.prototype, TO_STRING, function toString() {
      var R = anObject(this);
      var p = String(R.source);
      var rf = R.flags;
      var f = String(rf === undefined &amp;&amp; R instanceof RegExp &amp;&amp; !(&apos;flags&apos; in RegExpPrototype) ? regexpFlags.call(R) : rf);
      return &apos;/&apos; + p + &apos;/&apos; + f;
    }, { unsafe: true });
  }

  var MATCH = wellKnownSymbol(&apos;match&apos;);

  // `IsRegExp` abstract operation
  // https://tc39.es/ecma262/#sec-isregexp
  var isRegexp = function (it) {
    var isRegExp;
    return isObject(it) &amp;&amp; ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classofRaw(it) == &apos;RegExp&apos;);
  };

  var aFunction$1 = function (it) {
    if (typeof it != &apos;function&apos;) {
      throw TypeError(String(it) + &apos; is not a function&apos;);
    } return it;
  };

  var SPECIES$3 = wellKnownSymbol(&apos;species&apos;);

  // `SpeciesConstructor` abstract operation
  // https://tc39.es/ecma262/#sec-speciesconstructor
  var speciesConstructor = function (O, defaultConstructor) {
    var C = anObject(O).constructor;
    var S;
    return C === undefined || (S = anObject(C)[SPECIES$3]) == undefined ? defaultConstructor : aFunction$1(S);
  };

  var arrayPush = [].push;
  var min$2 = Math.min;
  var MAX_UINT32 = 0xFFFFFFFF;

  // babel-minify transpiles RegExp(&apos;x&apos;, &apos;y&apos;) -&gt; /x/y and it causes SyntaxError
  var SUPPORTS_Y = !fails(function () { return !RegExp(MAX_UINT32, &apos;y&apos;); });

  // @@split logic
  fixRegexpWellKnownSymbolLogic(&apos;split&apos;, 2, function (SPLIT, nativeSplit, maybeCallNative) {
    var internalSplit;
    if (
      &apos;abbc&apos;.split(/(b)*/)[1] == &apos;c&apos; ||
      &apos;test&apos;.split(/(?:)/, -1).length != 4 ||
      &apos;ab&apos;.split(/(?:ab)*/).length != 2 ||
      &apos;.&apos;.split(/(.?)(.?)/).length != 4 ||
      &apos;.&apos;.split(/()()/).length &gt; 1 ||
      &apos;&apos;.split(/.?/).length
    ) {
      // based on es5-shim implementation, need to rework it
      internalSplit = function (separator, limit) {
        var string = String(requireObjectCoercible(this));
        var lim = limit === undefined ? MAX_UINT32 : limit &gt;&gt;&gt; 0;
        if (lim === 0) return [];
        if (separator === undefined) return [string];
        // If `separator` is not a regex, use native split
        if (!isRegexp(separator)) {
          return nativeSplit.call(string, separator, lim);
        }
        var output = [];
        var flags = (separator.ignoreCase ? &apos;i&apos; : &apos;&apos;) +
                    (separator.multiline ? &apos;m&apos; : &apos;&apos;) +
                    (separator.unicode ? &apos;u&apos; : &apos;&apos;) +
                    (separator.sticky ? &apos;y&apos; : &apos;&apos;);
        var lastLastIndex = 0;
        // Make `global` and avoid `lastIndex` issues by working with a copy
        var separatorCopy = new RegExp(separator.source, flags + &apos;g&apos;);
        var match, lastIndex, lastLength;
        while (match = regexpExec.call(separatorCopy, string)) {
          lastIndex = separatorCopy.lastIndex;
          if (lastIndex &gt; lastLastIndex) {
            output.push(string.slice(lastLastIndex, match.index));
            if (match.length &gt; 1 &amp;&amp; match.index &lt; string.length) arrayPush.apply(output, match.slice(1));
            lastLength = match[0].length;
            lastLastIndex = lastIndex;
            if (output.length &gt;= lim) break;
          }
          if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
        }
        if (lastLastIndex === string.length) {
          if (lastLength || !separatorCopy.test(&apos;&apos;)) output.push(&apos;&apos;);
        } else output.push(string.slice(lastLastIndex));
        return output.length &gt; lim ? output.slice(0, lim) : output;
      };
    // Chakra, V8
    } else if (&apos;0&apos;.split(undefined, 0).length) {
      internalSplit = function (separator, limit) {
        return separator === undefined &amp;&amp; limit === 0 ? [] : nativeSplit.call(this, separator, limit);
      };
    } else internalSplit = nativeSplit;

    return [
      // `String.prototype.split` method
      // https://tc39.es/ecma262/#sec-string.prototype.split
      function split(separator, limit) {
        var O = requireObjectCoercible(this);
        var splitter = separator == undefined ? undefined : separator[SPLIT];
        return splitter !== undefined
          ? splitter.call(separator, O, limit)
          : internalSplit.call(String(O), separator, limit);
      },
      // `RegExp.prototype[@@split]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@split
      //
      // NOTE: This cannot be properly polyfilled in engines that don&apos;t support
      // the &apos;y&apos; flag.
      function (regexp, limit) {
        var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
        if (res.done) return res.value;

        var rx = anObject(regexp);
        var S = String(this);
        var C = speciesConstructor(rx, RegExp);

        var unicodeMatching = rx.unicode;
        var flags = (rx.ignoreCase ? &apos;i&apos; : &apos;&apos;) +
                    (rx.multiline ? &apos;m&apos; : &apos;&apos;) +
                    (rx.unicode ? &apos;u&apos; : &apos;&apos;) +
                    (SUPPORTS_Y ? &apos;y&apos; : &apos;g&apos;);

        // ^(? + rx + ) is needed, in combination with some S slicing, to
        // simulate the &apos;y&apos; flag.
        var splitter = new C(SUPPORTS_Y ? rx : &apos;^(?:&apos; + rx.source + &apos;)&apos;, flags);
        var lim = limit === undefined ? MAX_UINT32 : limit &gt;&gt;&gt; 0;
        if (lim === 0) return [];
        if (S.length === 0) return regexpExecAbstract(splitter, S) === null ? [S] : [];
        var p = 0;
        var q = 0;
        var A = [];
        while (q &lt; S.length) {
          splitter.lastIndex = SUPPORTS_Y ? q : 0;
          var z = regexpExecAbstract(splitter, SUPPORTS_Y ? S : S.slice(q));
          var e;
          if (
            z === null ||
            (e = min$2(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
          ) {
            q = advanceStringIndex(S, q, unicodeMatching);
          } else {
            A.push(S.slice(p, q));
            if (A.length === lim) return A;
            for (var i = 1; i &lt;= z.length - 1; i++) {
              A.push(z[i]);
              if (A.length === lim) return A;
            }
            q = p = e;
          }
        }
        A.push(S.slice(p));
        return A;
      }
    ];
  }, !SUPPORTS_Y);

  /**
   * Append a class to an element
   *
   * @api private
   * @method _addClass
   * @param {Object} element
   * @param {String} className
   * @returns null
   */

  function addClass(element, className) {
    if (element instanceof SVGElement) {
      // svg
      var pre = element.getAttribute(&quot;class&quot;) || &quot;&quot;;

      if (!pre.match(className)) {
        // check if element doesn&apos;t already have className
        element.setAttribute(&quot;class&quot;, &quot;&quot;.concat(pre, &quot; &quot;).concat(className));
      }
    } else {
      if (element.classList !== undefined) {
        // check for modern classList property
        var classes = className.split(&quot; &quot;);
        forEach(classes, function (cls) {
          element.classList.add(cls);
        });
      } else if (!element.className.match(className)) {
        // check if element doesn&apos;t already have className
        element.className += &quot; &quot;.concat(className);
      }
    }
  }

  /**
   * Get an element CSS property on the page
   * Thanks to JavaScript Kit: http://www.javascriptkit.com/dhtmltutors/dhtmlcascade4.shtml
   *
   * @api private
   * @method _getPropValue
   * @param {Object} element
   * @param {String} propName
   * @returns string property value
   */
  function getPropValue(element, propName) {
    var propValue = &quot;&quot;;

    if (element.currentStyle) {
      //IE
      propValue = element.currentStyle[propName];
    } else if (document.defaultView &amp;&amp; document.defaultView.getComputedStyle) {
      //Others
      propValue = document.defaultView.getComputedStyle(element, null).getPropertyValue(propName);
    } //Prevent exception in IE


    if (propValue &amp;&amp; propValue.toLowerCase) {
      return propValue.toLowerCase();
    } else {
      return propValue;
    }
  }

  /**
   * To set the show element
   * This function set a relative (in most cases) position and changes the z-index
   *
   * @api private
   * @method _setShowElement
   * @param {Object} targetElement
   */

  function setShowElement(_ref) {
    var element = _ref.element;
    addClass(element, &quot;introjs-showElement&quot;);
    var currentElementPosition = getPropValue(element, &quot;position&quot;);

    if (currentElementPosition !== &quot;absolute&quot; &amp;&amp; currentElementPosition !== &quot;relative&quot; &amp;&amp; currentElementPosition !== &quot;sticky&quot; &amp;&amp; currentElementPosition !== &quot;fixed&quot;) {
      //change to new intro item
      addClass(element, &quot;introjs-relativePosition&quot;);
    }
  }

  /**
   * Find the nearest scrollable parent
   * copied from https://stackoverflow.com/questions/35939886/find-first-scrollable-parent
   *
   * @param Element element
   * @return Element
   */
  function getScrollParent(element) {
    var style = window.getComputedStyle(element);
    var excludeStaticParent = style.position === &quot;absolute&quot;;
    var overflowRegex = /(auto|scroll)/;
    if (style.position === &quot;fixed&quot;) return document.body;

    for (var parent = element; parent = parent.parentElement;) {
      style = window.getComputedStyle(parent);

      if (excludeStaticParent &amp;&amp; style.position === &quot;static&quot;) {
        continue;
      }

      if (overflowRegex.test(style.overflow + style.overflowY + style.overflowX)) return parent;
    }

    return document.body;
  }

  /**
   * scroll a scrollable element to a child element
   *
   * @param {Object} targetElement
   */

  function scrollParentToElement(targetElement) {
    var element = targetElement.element;
    if (!this._options.scrollToElement) return;
    var parent = getScrollParent(element);
    if (parent === document.body) return;
    parent.scrollTop = element.offsetTop - parent.offsetTop;
  }

  /**
   * Provides a cross-browser way to get the screen dimensions
   * via: http://stackoverflow.com/questions/5864467/internet-explorer-innerheight
   *
   * @api private
   * @method _getWinSize
   * @returns {Object} width and height attributes
   */
  function getWinSize() {
    if (window.innerWidth !== undefined) {
      return {
        width: window.innerWidth,
        height: window.innerHeight
      };
    } else {
      var D = document.documentElement;
      return {
        width: D.clientWidth,
        height: D.clientHeight
      };
    }
  }

  /**
   * Check to see if the element is in the viewport or not
   * http://stackoverflow.com/questions/123999/how-to-tell-if-a-dom-element-is-visible-in-the-current-viewport
   *
   * @api private
   * @method _elementInViewport
   * @param {Object} el
   */
  function elementInViewport(el) {
    var rect = el.getBoundingClientRect();
    return rect.top &gt;= 0 &amp;&amp; rect.left &gt;= 0 &amp;&amp; rect.bottom + 80 &lt;= window.innerHeight &amp;&amp; // add 80 to get the text right
    rect.right &lt;= window.innerWidth;
  }

  /**
   * To change the scroll of `window` after highlighting an element
   *
   * @api private
   * @param {String} scrollTo
   * @param {Object} targetElement
   * @param {Object} tooltipLayer
   */

  function scrollTo(scrollTo, _ref, tooltipLayer) {
    var element = _ref.element;
    if (scrollTo === &quot;off&quot;) return;
    var rect;
    if (!this._options.scrollToElement) return;

    if (scrollTo === &quot;tooltip&quot;) {
      rect = tooltipLayer.getBoundingClientRect();
    } else {
      rect = element.getBoundingClientRect();
    }

    if (!elementInViewport(element)) {
      var winHeight = getWinSize().height;
      var top = rect.bottom - (rect.bottom - rect.top); // TODO (afshinm): do we need scroll padding now?
      // I have changed the scroll option and now it scrolls the window to
      // the center of the target element or tooltip.

      if (top &lt; 0 || element.clientHeight &gt; winHeight) {
        window.scrollBy(0, rect.top - (winHeight / 2 - rect.height / 2) - this._options.scrollPadding); // 30px padding from edge to look nice
        //Scroll down
      } else {
        window.scrollBy(0, rect.top - (winHeight / 2 - rect.height / 2) + this._options.scrollPadding); // 30px padding from edge to look nice
      }
    }
  }

  /**
   * Setting anchors to behave like buttons
   *
   * @api private
   * @method _setAnchorAsButton
   */
  function setAnchorAsButton(anchor) {
    anchor.setAttribute(&quot;role&quot;, &quot;button&quot;);
    anchor.tabIndex = 0;
  }

  /**
   * Get an element position on the page
   * Thanks to `meouw`: http://stackoverflow.com/a/442474/375966
   *
   * @api private
   * @method _getOffset
   * @param {Object} element
   * @returns Element&apos;s position info
   */
  function getOffset(element) {
    var body = document.body;
    var docEl = document.documentElement;
    var scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;
    var scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;
    var x = element.getBoundingClientRect();
    return {
      top: x.top + scrollTop,
      width: x.width,
      height: x.height,
      left: x.left + scrollLeft
    };
  }

  /**
   * Checks to see if target element (or parents) position is fixed or not
   *
   * @api private
   * @method _isFixed
   * @param {Object} element
   * @returns Boolean
   */

  function isFixed(element) {
    var p = element.parentNode;

    if (!p || p.nodeName === &quot;HTML&quot;) {
      return false;
    }

    if (getPropValue(element, &quot;position&quot;) === &quot;fixed&quot;) {
      return true;
    }

    return isFixed(p);
  }

  var floor$1 = Math.floor;
  var replace = &apos;&apos;.replace;
  var SUBSTITUTION_SYMBOLS = /\$([$&amp;&apos;`]|\d\d?|&lt;[^&gt;]*&gt;)/g;
  var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&amp;&apos;`]|\d\d?)/g;

  // https://tc39.es/ecma262/#sec-getsubstitution
  var getSubstitution = function (matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case &apos;$&apos;: return &apos;$&apos;;
        case &apos;&amp;&apos;: return matched;
        case &apos;`&apos;: return str.slice(0, position);
        case &quot;&apos;&quot;: return str.slice(tailPos);
        case &apos;&lt;&apos;:
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n &gt; m) {
            var f = floor$1(n / 10);
            if (f === 0) return match;
            if (f &lt;= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? &apos;&apos; : capture;
    });
  };

  var max$1 = Math.max;
  var min$3 = Math.min;

  var maybeToString = function (it) {
    return it === undefined ? it : String(it);
  };

  // @@replace logic
  fixRegexpWellKnownSymbolLogic(&apos;replace&apos;, 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {
    var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
    var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
    var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? &apos;$&apos; : &apos;$0&apos;;

    return [
      // `String.prototype.replace` method
      // https://tc39.es/ecma262/#sec-string.prototype.replace
      function replace(searchValue, replaceValue) {
        var O = requireObjectCoercible(this);
        var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
        return replacer !== undefined
          ? replacer.call(searchValue, O, replaceValue)
          : nativeReplace.call(String(O), searchValue, replaceValue);
      },
      // `RegExp.prototype[@@replace]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
      function (regexp, replaceValue) {
        if (
          (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE &amp;&amp; REPLACE_KEEPS_$0) ||
          (typeof replaceValue === &apos;string&apos; &amp;&amp; replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1)
        ) {
          var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
          if (res.done) return res.value;
        }

        var rx = anObject(regexp);
        var S = String(this);

        var functionalReplace = typeof replaceValue === &apos;function&apos;;
        if (!functionalReplace) replaceValue = String(replaceValue);

        var global = rx.global;
        if (global) {
          var fullUnicode = rx.unicode;
          rx.lastIndex = 0;
        }
        var results = [];
        while (true) {
          var result = regexpExecAbstract(rx, S);
          if (result === null) break;

          results.push(result);
          if (!global) break;

          var matchStr = String(result[0]);
          if (matchStr === &apos;&apos;) rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        }

        var accumulatedResult = &apos;&apos;;
        var nextSourcePosition = 0;
        for (var i = 0; i &lt; results.length; i++) {
          result = results[i];

          var matched = String(result[0]);
          var position = max$1(min$3(toInteger(result.index), S.length), 0);
          var captures = [];
          // NOTE: This is equivalent to
          //   captures = result.slice(1).map(maybeToString)
          // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
          // the slice polyfill when slicing native arrays) &quot;doesn&apos;t work&quot; in safari 9 and
          // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
          for (var j = 1; j &lt; result.length; j++) captures.push(maybeToString(result[j]));
          var namedCaptures = result.groups;
          if (functionalReplace) {
            var replacerArgs = [matched].concat(captures, position, S);
            if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
            var replacement = String(replaceValue.apply(undefined, replacerArgs));
          } else {
            replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
          }
          if (position &gt;= nextSourcePosition) {
            accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
            nextSourcePosition = position + matched.length;
          }
        }
        return accumulatedResult + S.slice(nextSourcePosition);
      }
    ];
  });

  /**
   * Remove a class from an element
   *
   * @api private
   * @method _removeClass
   * @param {Object} element
   * @param {RegExp|String} classNameRegex can be regex or string
   * @returns null
   */
  function removeClass(element, classNameRegex) {
    if (element instanceof SVGElement) {
      var pre = element.getAttribute(&quot;class&quot;) || &quot;&quot;;
      element.setAttribute(&quot;class&quot;, pre.replace(classNameRegex, &quot;&quot;).replace(/^\s+|\s+$/g, &quot;&quot;));
    } else {
      element.className = element.className.replace(classNameRegex, &quot;&quot;).replace(/^\s+|\s+$/g, &quot;&quot;);
    }
  }

  /**
   * Sets the style of an DOM element
   *
   * @param {Object} element
   * @param {Object|string} style
   * @return null
   */
  function setStyle(element, style) {
    var cssText = &quot;&quot;;

    if (element.style.cssText) {
      cssText += element.style.cssText;
    }

    if (typeof style === &quot;string&quot;) {
      cssText += style;
    } else {
      for (var rule in style) {
        cssText += &quot;&quot;.concat(rule, &quot;:&quot;).concat(style[rule], &quot;;&quot;);
      }
    }

    element.style.cssText = cssText;
  }

  /**
   * Update the position of the helper layer on the screen
   *
   * @api private
   * @method _setHelperLayerPosition
   * @param {Object} helperLayer
   */

  function setHelperLayerPosition(helperLayer) {
    if (helperLayer) {
      //prevent error when `this._currentStep` in undefined
      if (!this._introItems[this._currentStep]) return;
      var currentElement = this._introItems[this._currentStep];
      var elementPosition = getOffset(currentElement.element);
      var widthHeightPadding = this._options.helperElementPadding; // If the target element is fixed, the tooltip should be fixed as well.
      // Otherwise, remove a fixed class that may be left over from the previous
      // step.

      if (isFixed(currentElement.element)) {
        addClass(helperLayer, &quot;introjs-fixedTooltip&quot;);
      } else {
        removeClass(helperLayer, &quot;introjs-fixedTooltip&quot;);
      }

      if (currentElement.position === &quot;floating&quot;) {
        widthHeightPadding = 0;
      } //set new position to helper layer


      setStyle(helperLayer, {
        width: &quot;&quot;.concat(elementPosition.width + widthHeightPadding, &quot;px&quot;),
        height: &quot;&quot;.concat(elementPosition.height + widthHeightPadding, &quot;px&quot;),
        top: &quot;&quot;.concat(elementPosition.top - widthHeightPadding / 2, &quot;px&quot;),
        left: &quot;&quot;.concat(elementPosition.left - widthHeightPadding / 2, &quot;px&quot;)
      });
    }
  }

  // optional / simple context binding
  var functionBindContext = function (fn, that, length) {
    aFunction$1(fn);
    if (that === undefined) return fn;
    switch (length) {
      case 0: return function () {
        return fn.call(that);
      };
      case 1: return function (a) {
        return fn.call(that, a);
      };
      case 2: return function (a, b) {
        return fn.call(that, a, b);
      };
      case 3: return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
    }
    return function (/* ...args */) {
      return fn.apply(that, arguments);
    };
  };

  var push = [].push;

  // `Array.prototype.{ forEach, map, filter, some, every, find, findIndex, filterOut }` methods implementation
  var createMethod$2 = function (TYPE) {
    var IS_MAP = TYPE == 1;
    var IS_FILTER = TYPE == 2;
    var IS_SOME = TYPE == 3;
    var IS_EVERY = TYPE == 4;
    var IS_FIND_INDEX = TYPE == 6;
    var IS_FILTER_OUT = TYPE == 7;
    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    return function ($this, callbackfn, that, specificCreate) {
      var O = toObject($this);
      var self = indexedObject(O);
      var boundFunction = functionBindContext(callbackfn, that, 3);
      var length = toLength(self.length);
      var index = 0;
      var create = specificCreate || arraySpeciesCreate;
      var target = IS_MAP ? create($this, length) : IS_FILTER || IS_FILTER_OUT ? create($this, 0) : undefined;
      var value, result;
      for (;length &gt; index; index++) if (NO_HOLES || index in self) {
        value = self[index];
        result = boundFunction(value, index, O);
        if (TYPE) {
          if (IS_MAP) target[index] = result; // map
          else if (result) switch (TYPE) {
            case 3: return true;              // some
            case 5: return value;             // find
            case 6: return index;             // findIndex
            case 2: push.call(target, value); // filter
          } else switch (TYPE) {
            case 4: return false;             // every
            case 7: push.call(target, value); // filterOut
          }
        }
      }
      return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
    };
  };

  var arrayIteration = {
    // `Array.prototype.forEach` method
    // https://tc39.es/ecma262/#sec-array.prototype.foreach
    forEach: createMethod$2(0),
    // `Array.prototype.map` method
    // https://tc39.es/ecma262/#sec-array.prototype.map
    map: createMethod$2(1),
    // `Array.prototype.filter` method
    // https://tc39.es/ecma262/#sec-array.prototype.filter
    filter: createMethod$2(2),
    // `Array.prototype.some` method
    // https://tc39.es/ecma262/#sec-array.prototype.some
    some: createMethod$2(3),
    // `Array.prototype.every` method
    // https://tc39.es/ecma262/#sec-array.prototype.every
    every: createMethod$2(4),
    // `Array.prototype.find` method
    // https://tc39.es/ecma262/#sec-array.prototype.find
    find: createMethod$2(5),
    // `Array.prototype.findIndex` method
    // https://tc39.es/ecma262/#sec-array.prototype.findIndex
    findIndex: createMethod$2(6),
    // `Array.prototype.filterOut` method
    // https://github.com/tc39/proposal-array-filtering
    filterOut: createMethod$2(7)
  };

  var defineProperty = Object.defineProperty;
  var cache = {};

  var thrower = function (it) { throw it; };

  var arrayMethodUsesToLength = function (METHOD_NAME, options) {
    if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
    if (!options) options = {};
    var method = [][METHOD_NAME];
    var ACCESSORS = has(options, &apos;ACCESSORS&apos;) ? options.ACCESSORS : false;
    var argument0 = has(options, 0) ? options[0] : thrower;
    var argument1 = has(options, 1) ? options[1] : undefined;

    return cache[METHOD_NAME] = !!method &amp;&amp; !fails(function () {
      if (ACCESSORS &amp;&amp; !descriptors) return true;
      var O = { length: -1 };

      if (ACCESSORS) defineProperty(O, 1, { enumerable: true, get: thrower });
      else O[1] = 1;

      method.call(O, argument0, argument1);
    });
  };

  var $filter = arrayIteration.filter;



  var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport(&apos;filter&apos;);
  // Edge 14- issue
  var USES_TO_LENGTH = arrayMethodUsesToLength(&apos;filter&apos;);

  // `Array.prototype.filter` method
  // https://tc39.es/ecma262/#sec-array.prototype.filter
  // with adding support of @@species
  _export({ target: &apos;Array&apos;, proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
    filter: function filter(callbackfn /* , thisArg */) {
      return $filter(this, callbackfn, arguments.length &gt; 1 ? arguments[1] : undefined);
    }
  });

  // `Object.keys` method
  // https://tc39.es/ecma262/#sec-object.keys
  var objectKeys = Object.keys || function keys(O) {
    return objectKeysInternal(O, enumBugKeys);
  };

  // `Object.defineProperties` method
  // https://tc39.es/ecma262/#sec-object.defineproperties
  var objectDefineProperties = descriptors ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject(O);
    var keys = objectKeys(Properties);
    var length = keys.length;
    var index = 0;
    var key;
    while (length &gt; index) objectDefineProperty.f(O, key = keys[index++], Properties[key]);
    return O;
  };

  var html = getBuiltIn(&apos;document&apos;, &apos;documentElement&apos;);

  var GT = &apos;&gt;&apos;;
  var LT = &apos;&lt;&apos;;
  var PROTOTYPE = &apos;prototype&apos;;
  var SCRIPT = &apos;script&apos;;
  var IE_PROTO = sharedKey(&apos;IE_PROTO&apos;);

  var EmptyConstructor = function () { /* empty */ };

  var scriptTag = function (content) {
    return LT + SCRIPT + GT + content + LT + &apos;/&apos; + SCRIPT + GT;
  };

  // Create object with fake `null` prototype: use ActiveX Object with cleared prototype
  var NullProtoObjectViaActiveX = function (activeXDocument) {
    activeXDocument.write(scriptTag(&apos;&apos;));
    activeXDocument.close();
    var temp = activeXDocument.parentWindow.Object;
    activeXDocument = null; // avoid memory leak
    return temp;
  };

  // Create object with fake `null` prototype: use iframe Object with cleared prototype
  var NullProtoObjectViaIFrame = function () {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = documentCreateElement(&apos;iframe&apos;);
    var JS = &apos;java&apos; + SCRIPT + &apos;:&apos;;
    var iframeDocument;
    iframe.style.display = &apos;none&apos;;
    html.appendChild(iframe);
    // https://github.com/zloirock/core-js/issues/475
    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag(&apos;document.F=Object&apos;));
    iframeDocument.close();
    return iframeDocument.F;
  };

  // Check for document.domain and active x support
  // No need to use active x approach when document.domain is not set
  // see https://github.com/es-shims/es5-shim/issues/150
  // variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
  // avoid IE GC bug
  var activeXDocument;
  var NullProtoObject = function () {
    try {
      /* global ActiveXObject */
      activeXDocument = document.domain &amp;&amp; new ActiveXObject(&apos;htmlfile&apos;);
    } catch (error) { /* ignore */ }
    NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
    var length = enumBugKeys.length;
    while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
    return NullProtoObject();
  };

  hiddenKeys[IE_PROTO] = true;

  // `Object.create` method
  // https://tc39.es/ecma262/#sec-object.create
  var objectCreate = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
      EmptyConstructor[PROTOTYPE] = anObject(O);
      result = new EmptyConstructor();
      EmptyConstructor[PROTOTYPE] = null;
      // add &quot;__proto__&quot; for Object.getPrototypeOf polyfill
      result[IE_PROTO] = O;
    } else result = NullProtoObject();
    return Properties === undefined ? result : objectDefineProperties(result, Properties);
  };

  var UNSCOPABLES = wellKnownSymbol(&apos;unscopables&apos;);
  var ArrayPrototype = Array.prototype;

  // Array.prototype[@@unscopables]
  // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
  if (ArrayPrototype[UNSCOPABLES] == undefined) {
    objectDefineProperty.f(ArrayPrototype, UNSCOPABLES, {
      configurable: true,
      value: objectCreate(null)
    });
  }

  // add a key to Array.prototype[@@unscopables]
  var addToUnscopables = function (key) {
    ArrayPrototype[UNSCOPABLES][key] = true;
  };

  var $includes = arrayIncludes.includes;



  var USES_TO_LENGTH$1 = arrayMethodUsesToLength(&apos;indexOf&apos;, { ACCESSORS: true, 1: 0 });

  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  _export({ target: &apos;Array&apos;, proto: true, forced: !USES_TO_LENGTH$1 }, {
    includes: function includes(el /* , fromIndex = 0 */) {
      return $includes(this, el, arguments.length &gt; 1 ? arguments[1] : undefined);
    }
  });

  // https://tc39.es/ecma262/#sec-array.prototype-@@unscopables
  addToUnscopables(&apos;includes&apos;);

  var arrayMethodIsStrict = function (METHOD_NAME, argument) {
    var method = [][METHOD_NAME];
    return !!method &amp;&amp; fails(function () {
      // eslint-disable-next-line no-useless-call,no-throw-literal
      method.call(null, argument || function () { throw 1; }, 1);
    });
  };

  var $indexOf = arrayIncludes.indexOf;



  var nativeIndexOf = [].indexOf;

  var NEGATIVE_ZERO = !!nativeIndexOf &amp;&amp; 1 / [1].indexOf(1, -0) &lt; 0;
  var STRICT_METHOD = arrayMethodIsStrict(&apos;indexOf&apos;);
  var USES_TO_LENGTH$2 = arrayMethodUsesToLength(&apos;indexOf&apos;, { ACCESSORS: true, 1: 0 });

  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  _export({ target: &apos;Array&apos;, proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD || !USES_TO_LENGTH$2 }, {
    indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
      return NEGATIVE_ZERO
        // convert -0 to +0
        ? nativeIndexOf.apply(this, arguments) || 0
        : $indexOf(this, searchElement, arguments.length &gt; 1 ? arguments[1] : undefined);
    }
  });

  var nativeJoin = [].join;

  var ES3_STRINGS = indexedObject != Object;
  var STRICT_METHOD$1 = arrayMethodIsStrict(&apos;join&apos;, &apos;,&apos;);

  // `Array.prototype.join` method
  // https://tc39.es/ecma262/#sec-array.prototype.join
  _export({ target: &apos;Array&apos;, proto: true, forced: ES3_STRINGS || !STRICT_METHOD$1 }, {
    join: function join(separator) {
      return nativeJoin.call(toIndexedObject(this), separator === undefined ? &apos;,&apos; : separator);
    }
  });

  var HAS_SPECIES_SUPPORT$1 = arrayMethodHasSpeciesSupport(&apos;slice&apos;);
  var USES_TO_LENGTH$3 = arrayMethodUsesToLength(&apos;slice&apos;, { ACCESSORS: true, 0: 0, 1: 2 });

  var SPECIES$4 = wellKnownSymbol(&apos;species&apos;);
  var nativeSlice = [].slice;
  var max$2 = Math.max;

  // `Array.prototype.slice` method
  // https://tc39.es/ecma262/#sec-array.prototype.slice
  // fallback for not array-like ES3 strings and DOM objects
  _export({ target: &apos;Array&apos;, proto: true, forced: !HAS_SPECIES_SUPPORT$1 || !USES_TO_LENGTH$3 }, {
    slice: function slice(start, end) {
      var O = toIndexedObject(this);
      var length = toLength(O.length);
      var k = toAbsoluteIndex(start, length);
      var fin = toAbsoluteIndex(end === undefined ? length : end, length);
      // inline `ArraySpeciesCreate` for usage native `Array#slice` where it&apos;s possible
      var Constructor, result, n;
      if (isArray(O)) {
        Constructor = O.constructor;
        // cross-realm fallback
        if (typeof Constructor == &apos;function&apos; &amp;&amp; (Constructor === Array || isArray(Constructor.prototype))) {
          Constructor = undefined;
        } else if (isObject(Constructor)) {
          Constructor = Constructor[SPECIES$4];
          if (Constructor === null) Constructor = undefined;
        }
        if (Constructor === Array || Constructor === undefined) {
          return nativeSlice.call(O, k, fin);
        }
      }
      result = new (Constructor === undefined ? Array : Constructor)(max$2(fin - k, 0));
      for (n = 0; k &lt; fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
      result.length = n;
      return result;
    }
  });

  var notARegexp = function (it) {
    if (isRegexp(it)) {
      throw TypeError(&quot;The method doesn&apos;t accept regular expressions&quot;);
    } return it;
  };

  var MATCH$1 = wellKnownSymbol(&apos;match&apos;);

  var correctIsRegexpLogic = function (METHOD_NAME) {
    var regexp = /./;
    try {
      &apos;/./&apos;[METHOD_NAME](regexp);
    } catch (error1) {
      try {
        regexp[MATCH$1] = false;
        return &apos;/./&apos;[METHOD_NAME](regexp);
      } catch (error2) { /* empty */ }
    } return false;
  };

  // `String.prototype.includes` method
  // https://tc39.es/ecma262/#sec-string.prototype.includes
  _export({ target: &apos;String&apos;, proto: true, forced: !correctIsRegexpLogic(&apos;includes&apos;) }, {
    includes: function includes(searchString /* , position = 0 */) {
      return !!~String(requireObjectCoercible(this))
        .indexOf(notARegexp(searchString), arguments.length &gt; 1 ? arguments[1] : undefined);
    }
  });

  /**
   * Set tooltip left so it doesn&apos;t go off the right side of the window
   *
   * @return boolean true, if tooltipLayerStyleLeft is ok.  false, otherwise.
   */
  function checkRight(targetOffset, tooltipLayerStyleLeft, tooltipOffset, windowSize, tooltipLayer) {
    if (targetOffset.left + tooltipLayerStyleLeft + tooltipOffset.width &gt; windowSize.width) {
      // off the right side of the window
      tooltipLayer.left = &quot;&quot;.concat(windowSize.width - tooltipOffset.width - targetOffset.left, &quot;px&quot;);
      return false;
    }

    tooltipLayer.left = &quot;&quot;.concat(tooltipLayerStyleLeft, &quot;px&quot;);
    return true;
  }

  /**
   * Set tooltip right so it doesn&apos;t go off the left side of the window
   *
   * @return boolean true, if tooltipLayerStyleRight is ok.  false, otherwise.
   */
  function checkLeft(targetOffset, tooltipLayerStyleRight, tooltipOffset, tooltipLayer) {
    if (targetOffset.left + targetOffset.width - tooltipLayerStyleRight - tooltipOffset.width &lt; 0) {
      // off the left side of the window
      tooltipLayer.style.left = &quot;&quot;.concat(-targetOffset.left, &quot;px&quot;);
      return false;
    }

    tooltipLayer.style.right = &quot;&quot;.concat(tooltipLayerStyleRight, &quot;px&quot;);
    return true;
  }

  var HAS_SPECIES_SUPPORT$2 = arrayMethodHasSpeciesSupport(&apos;splice&apos;);
  var USES_TO_LENGTH$4 = arrayMethodUsesToLength(&apos;splice&apos;, { ACCESSORS: true, 0: 0, 1: 2 });

  var max$3 = Math.max;
  var min$4 = Math.min;
  var MAX_SAFE_INTEGER$1 = 0x1FFFFFFFFFFFFF;
  var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = &apos;Maximum allowed length exceeded&apos;;

  // `Array.prototype.splice` method
  // https://tc39.es/ecma262/#sec-array.prototype.splice
  // with adding support of @@species
  _export({ target: &apos;Array&apos;, proto: true, forced: !HAS_SPECIES_SUPPORT$2 || !USES_TO_LENGTH$4 }, {
    splice: function splice(start, deleteCount /* , ...items */) {
      var O = toObject(this);
      var len = toLength(O.length);
      var actualStart = toAbsoluteIndex(start, len);
      var argumentsLength = arguments.length;
      var insertCount, actualDeleteCount, A, k, from, to;
      if (argumentsLength === 0) {
        insertCount = actualDeleteCount = 0;
      } else if (argumentsLength === 1) {
        insertCount = 0;
        actualDeleteCount = len - actualStart;
      } else {
        insertCount = argumentsLength - 2;
        actualDeleteCount = min$4(max$3(toInteger(deleteCount), 0), len - actualStart);
      }
      if (len + insertCount - actualDeleteCount &gt; MAX_SAFE_INTEGER$1) {
        throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
      }
      A = arraySpeciesCreate(O, actualDeleteCount);
      for (k = 0; k &lt; actualDeleteCount; k++) {
        from = actualStart + k;
        if (from in O) createProperty(A, k, O[from]);
      }
      A.length = actualDeleteCount;
      if (insertCount &lt; actualDeleteCount) {
        for (k = actualStart; k &lt; len - actualDeleteCount; k++) {
          from = k + actualDeleteCount;
          to = k + insertCount;
          if (from in O) O[to] = O[from];
          else delete O[to];
        }
        for (k = len; k &gt; len - actualDeleteCount + insertCount; k--) delete O[k - 1];
      } else if (insertCount &gt; actualDeleteCount) {
        for (k = len - actualDeleteCount; k &gt; actualStart; k--) {
          from = k + actualDeleteCount - 1;
          to = k + insertCount - 1;
          if (from in O) O[to] = O[from];
          else delete O[to];
        }
      }
      for (k = 0; k &lt; insertCount; k++) {
        O[k + actualStart] = arguments[k + 2];
      }
      O.length = len - actualDeleteCount + insertCount;
      return A;
    }
  });

  /**
   * Remove an entry from a string array if it&apos;s there, does nothing if it isn&apos;t there.
   *
   * @param {Array} stringArray
   * @param {String} stringToRemove
   */
  function removeEntry(stringArray, stringToRemove) {
    if (stringArray.includes(stringToRemove)) {
      stringArray.splice(stringArray.indexOf(stringToRemove), 1);
    }
  }

  /**
   * auto-determine alignment
   * @param {Integer}  offsetLeft
   * @param {Integer}  tooltipWidth
   * @param {Object}   windowSize
   * @param {String}   desiredAlignment
   * @return {String}  calculatedAlignment
   */

  function _determineAutoAlignment(offsetLeft, tooltipWidth, _ref, desiredAlignment) {
    var width = _ref.width;
    var halfTooltipWidth = tooltipWidth / 2;
    var winWidth = Math.min(width, window.screen.width);
    var possibleAlignments = [&quot;-left-aligned&quot;, &quot;-middle-aligned&quot;, &quot;-right-aligned&quot;];
    var calculatedAlignment = &quot;&quot;; // valid left must be at least a tooltipWidth
    // away from right side

    if (winWidth - offsetLeft &lt; tooltipWidth) {
      removeEntry(possibleAlignments, &quot;-left-aligned&quot;);
    } // valid middle must be at least half
    // width away from both sides


    if (offsetLeft &lt; halfTooltipWidth || winWidth - offsetLeft &lt; halfTooltipWidth) {
      removeEntry(possibleAlignments, &quot;-middle-aligned&quot;);
    } // valid right must be at least a tooltipWidth
    // width away from left side


    if (offsetLeft &lt; tooltipWidth) {
      removeEntry(possibleAlignments, &quot;-right-aligned&quot;);
    }

    if (possibleAlignments.length) {
      if (possibleAlignments.includes(desiredAlignment)) {
        // the desired alignment is valid
        calculatedAlignment = desiredAlignment;
      } else {
        // pick the first valid position, in order
        calculatedAlignment = possibleAlignments[0];
      }
    } else {
      // if screen width is too small
      // for ANY alignment, middle is
      // probably the best for visibility
      calculatedAlignment = &quot;-middle-aligned&quot;;
    }

    return calculatedAlignment;
  }
  /**
   * Determines the position of the tooltip based on the position precedence and availability
   * of screen space.
   *
   * @param {Object}    targetElement
   * @param {Object}    tooltipLayer
   * @param {String}    desiredTooltipPosition
   * @return {String}   calculatedPosition
   */


  function _determineAutoPosition(targetElement, tooltipLayer, desiredTooltipPosition) {
    // Take a clone of position precedence. These will be the available
    var possiblePositions = this._options.positionPrecedence.slice();

    var windowSize = getWinSize();
    var tooltipHeight = getOffset(tooltipLayer).height + 10;
    var tooltipWidth = getOffset(tooltipLayer).width + 20;
    var targetElementRect = targetElement.getBoundingClientRect(); // If we check all the possible areas, and there are no valid places for the tooltip, the element
    // must take up most of the screen real estate. Show the tooltip floating in the middle of the screen.

    var calculatedPosition = &quot;floating&quot;;
    /*
     * auto determine position
     */
    // Check for space below

    if (targetElementRect.bottom + tooltipHeight &gt; windowSize.height) {
      removeEntry(possiblePositions, &quot;bottom&quot;);
    } // Check for space above


    if (targetElementRect.top - tooltipHeight &lt; 0) {
      removeEntry(possiblePositions, &quot;top&quot;);
    } // Check for space to the right


    if (targetElementRect.right + tooltipWidth &gt; windowSize.width) {
      removeEntry(possiblePositions, &quot;right&quot;);
    } // Check for space to the left


    if (targetElementRect.left - tooltipWidth &lt; 0) {
      removeEntry(possiblePositions, &quot;left&quot;);
    } // @var {String}  ex: &apos;right-aligned&apos;


    var desiredAlignment = function (pos) {
      var hyphenIndex = pos.indexOf(&quot;-&quot;);

      if (hyphenIndex !== -1) {
        // has alignment
        return pos.substr(hyphenIndex);
      }

      return &quot;&quot;;
    }(desiredTooltipPosition || &quot;&quot;); // strip alignment from position


    if (desiredTooltipPosition) {
      // ex: &quot;bottom-right-aligned&quot;
      // should return &apos;bottom&apos;
      desiredTooltipPosition = desiredTooltipPosition.split(&quot;-&quot;)[0];
    }

    if (possiblePositions.length) {
      if (possiblePositions.includes(desiredTooltipPosition)) {
        // If the requested position is in the list, choose that
        calculatedPosition = desiredTooltipPosition;
      } else {
        // Pick the first valid position, in order
        calculatedPosition = possiblePositions[0];
      }
    } // only top and bottom positions have optional alignments


    if ([&quot;top&quot;, &quot;bottom&quot;].includes(calculatedPosition)) {
      calculatedPosition += _determineAutoAlignment(targetElementRect.left, tooltipWidth, windowSize, desiredAlignment);
    }

    return calculatedPosition;
  }
  /**
   * Render tooltip box in the page
   *
   * @api private
   * @method placeTooltip
   * @param {HTMLElement} targetElement
   * @param {HTMLElement} tooltipLayer
   * @param {HTMLElement} arrowLayer
   * @param {Boolean} hintMode
   */


  function placeTooltip(targetElement, tooltipLayer, arrowLayer, hintMode) {
    var tooltipCssClass = &quot;&quot;;
    var currentStepObj;
    var tooltipOffset;
    var targetOffset;
    var windowSize;
    var currentTooltipPosition;
    hintMode = hintMode || false; //reset the old style

    tooltipLayer.style.top = null;
    tooltipLayer.style.right = null;
    tooltipLayer.style.bottom = null;
    tooltipLayer.style.left = null;
    tooltipLayer.style.marginLeft = null;
    tooltipLayer.style.marginTop = null;
    arrowLayer.style.display = &quot;inherit&quot;; //prevent error when `this._currentStep` is undefined

    if (!this._introItems[this._currentStep]) return; //if we have a custom css class for each step

    currentStepObj = this._introItems[this._currentStep];

    if (typeof currentStepObj.tooltipClass === &quot;string&quot;) {
      tooltipCssClass = currentStepObj.tooltipClass;
    } else {
      tooltipCssClass = this._options.tooltipClass;
    }

    tooltipLayer.className = [&quot;introjs-tooltip&quot;, tooltipCssClass].filter(Boolean).join(&quot; &quot;);
    tooltipLayer.setAttribute(&quot;role&quot;, &quot;dialog&quot;);
    currentTooltipPosition = this._introItems[this._currentStep].position; // Floating is always valid, no point in calculating

    if (currentTooltipPosition !== &quot;floating&quot; &amp;&amp; this._options.autoPosition) {
      currentTooltipPosition = _determineAutoPosition.call(this, targetElement, tooltipLayer, currentTooltipPosition);
    }

    var tooltipLayerStyleLeft;
    targetOffset = getOffset(targetElement);
    tooltipOffset = getOffset(tooltipLayer);
    windowSize = getWinSize();
    addClass(tooltipLayer, &quot;introjs-&quot;.concat(currentTooltipPosition));

    switch (currentTooltipPosition) {
      case &quot;top-right-aligned&quot;:
        arrowLayer.className = &quot;introjs-arrow bottom-right&quot;;
        var tooltipLayerStyleRight = 0;
        checkLeft(targetOffset, tooltipLayerStyleRight, tooltipOffset, tooltipLayer);
        tooltipLayer.style.bottom = &quot;&quot;.concat(targetOffset.height + 20, &quot;px&quot;);
        break;

      case &quot;top-middle-aligned&quot;:
        arrowLayer.className = &quot;introjs-arrow bottom-middle&quot;;
        var tooltipLayerStyleLeftRight = targetOffset.width / 2 - tooltipOffset.width / 2; // a fix for middle aligned hints

        if (hintMode) {
          tooltipLayerStyleLeftRight += 5;
        }

        if (checkLeft(targetOffset, tooltipLayerStyleLeftRight, tooltipOffset, tooltipLayer)) {
          tooltipLayer.style.right = null;
          checkRight(targetOffset, tooltipLayerStyleLeftRight, tooltipOffset, windowSize, tooltipLayer);
        }

        tooltipLayer.style.bottom = &quot;&quot;.concat(targetOffset.height + 20, &quot;px&quot;);
        break;

      case &quot;top-left-aligned&quot;: // top-left-aligned is the same as the default top

      case &quot;top&quot;:
        arrowLayer.className = &quot;introjs-arrow bottom&quot;;
        tooltipLayerStyleLeft = hintMode ? 0 : 15;
        checkRight(targetOffset, tooltipLayerStyleLeft, tooltipOffset, windowSize, tooltipLayer);
        tooltipLayer.style.bottom = &quot;&quot;.concat(targetOffset.height + 20, &quot;px&quot;);
        break;

      case &quot;right&quot;:
        tooltipLayer.style.left = &quot;&quot;.concat(targetOffset.width + 20, &quot;px&quot;);

        if (targetOffset.top + tooltipOffset.height &gt; windowSize.height) {
          // In this case, right would have fallen below the bottom of the screen.
          // Modify so that the bottom of the tooltip connects with the target
          arrowLayer.className = &quot;introjs-arrow left-bottom&quot;;
          tooltipLayer.style.top = &quot;-&quot;.concat(tooltipOffset.height - targetOffset.height - 20, &quot;px&quot;);
        } else {
          arrowLayer.className = &quot;introjs-arrow left&quot;;
        }

        break;

      case &quot;left&quot;:
        if (!hintMode &amp;&amp; this._options.showStepNumbers === true) {
          tooltipLayer.style.top = &quot;15px&quot;;
        }

        if (targetOffset.top + tooltipOffset.height &gt; windowSize.height) {
          // In this case, left would have fallen below the bottom of the screen.
          // Modify so that the bottom of the tooltip connects with the target
          tooltipLayer.style.top = &quot;-&quot;.concat(tooltipOffset.height - targetOffset.height - 20, &quot;px&quot;);
          arrowLayer.className = &quot;introjs-arrow right-bottom&quot;;
        } else {
          arrowLayer.className = &quot;introjs-arrow right&quot;;
        }

        tooltipLayer.style.right = &quot;&quot;.concat(targetOffset.width + 20, &quot;px&quot;);
        break;

      case &quot;floating&quot;:
        arrowLayer.style.display = &quot;none&quot;; //we have to adjust the top and left of layer manually for intro items without element

        tooltipLayer.style.left = &quot;50%&quot;;
        tooltipLayer.style.top = &quot;50%&quot;;
        tooltipLayer.style.marginLeft = &quot;-&quot;.concat(tooltipOffset.width / 2, &quot;px&quot;);
        tooltipLayer.style.marginTop = &quot;-&quot;.concat(tooltipOffset.height / 2, &quot;px&quot;);
        break;

      case &quot;bottom-right-aligned&quot;:
        arrowLayer.className = &quot;introjs-arrow top-right&quot;;
        tooltipLayerStyleRight = 0;
        checkLeft(targetOffset, tooltipLayerStyleRight, tooltipOffset, tooltipLayer);
        tooltipLayer.style.top = &quot;&quot;.concat(targetOffset.height + 20, &quot;px&quot;);
        break;

      case &quot;bottom-middle-aligned&quot;:
        arrowLayer.className = &quot;introjs-arrow top-middle&quot;;
        tooltipLayerStyleLeftRight = targetOffset.width / 2 - tooltipOffset.width / 2; // a fix for middle aligned hints

        if (hintMode) {
          tooltipLayerStyleLeftRight += 5;
        }

        if (checkLeft(targetOffset, tooltipLayerStyleLeftRight, tooltipOffset, tooltipLayer)) {
          tooltipLayer.style.right = null;
          checkRight(targetOffset, tooltipLayerStyleLeftRight, tooltipOffset, windowSize, tooltipLayer);
        }

        tooltipLayer.style.top = &quot;&quot;.concat(targetOffset.height + 20, &quot;px&quot;);
        break;
      // case &apos;bottom-left-aligned&apos;:
      // Bottom-left-aligned is the same as the default bottom
      // case &apos;bottom&apos;:
      // Bottom going to follow the default behavior

      default:
        arrowLayer.className = &quot;introjs-arrow top&quot;;
        tooltipLayerStyleLeft = 0;
        checkRight(targetOffset, tooltipLayerStyleLeft, tooltipOffset, windowSize, tooltipLayer);
        tooltipLayer.style.top = &quot;&quot;.concat(targetOffset.height + 20, &quot;px&quot;);
    }
  }

  /**
   * To remove all show element(s)
   *
   * @api private
   * @method _removeShowElement
   */

  function removeShowElement() {
    var elms = document.querySelectorAll(&quot;.introjs-showElement&quot;);
    forEach(elms, function (elm) {
      removeClass(elm, /introjs-[a-zA-Z]+/g);
    });
  }

  function _createElement(tagname, attrs) {
    var element = document.createElement(tagname);
    attrs = attrs || {}; // regex for matching attributes that need to be set with setAttribute

    var setAttRegex = /^(?:role|data-|aria-)/;

    for (var k in attrs) {
      var v = attrs[k];

      if (k === &quot;style&quot;) {
        setStyle(element, v);
      } else if (k.match(setAttRegex)) {
        element.setAttribute(k, v);
      } else {
        element[k] = v;
      }
    }

    return element;
  }

  /**
   * Appends `element` to `parentElement`
   *
   * @param {Element} parentElement
   * @param {Element} element
   * @param {Boolean} [animate=false]
   */

  function appendChild(parentElement, element, animate) {
    if (animate) {
      var existingOpacity = element.style.opacity || &quot;1&quot;;
      setStyle(element, {
        opacity: &quot;0&quot;
      });
      window.setTimeout(function () {
        setStyle(element, {
          opacity: existingOpacity
        });
      }, 10);
    }

    parentElement.appendChild(element);
  }

  /**
   * Gets the current progress percentage
   *
   * @api private
   * @method _getProgress
   * @returns current progress percentage
   */

  function _getProgress() {
    // Steps are 0 indexed
    var currentStep = parseInt(this._currentStep + 1, 10);
    return currentStep / this._introItems.length * 100;
  }
  /**
   * Add disableinteraction layer and adjust the size and position of the layer
   *
   * @api private
   * @method _disableInteraction
   */


  function _disableInteraction() {
    var disableInteractionLayer = document.querySelector(&quot;.introjs-disableInteraction&quot;);

    if (disableInteractionLayer === null) {
      disableInteractionLayer = _createElement(&quot;div&quot;, {
        className: &quot;introjs-disableInteraction&quot;
      });

      this._targetElement.appendChild(disableInteractionLayer);
    }

    setHelperLayerPosition.call(this, disableInteractionLayer);
  }
  /**
   * Show an element on the page
   *
   * @api private
   * @method _showElement
   * @param {Object} targetElement
   */


  function _showElement(targetElement) {
    var _this = this;

    if (typeof this._introChangeCallback !== &quot;undefined&quot;) {
      this._introChangeCallback.call(this, targetElement.element);
    }

    var self = this;
    var oldHelperLayer = document.querySelector(&quot;.introjs-helperLayer&quot;);
    var oldReferenceLayer = document.querySelector(&quot;.introjs-tooltipReferenceLayer&quot;);
    var highlightClass = &quot;introjs-helperLayer&quot;;
    var nextTooltipButton;
    var prevTooltipButton;
    var skipTooltipButton;

    if (typeof targetElement.highlightClass === &quot;string&quot;) {
      highlightClass += &quot; &quot;.concat(targetElement.highlightClass);
    } //check for options highlight class


    if (typeof this._options.highlightClass === &quot;string&quot;) {
      highlightClass += &quot; &quot;.concat(this._options.highlightClass);
    }

    if (oldHelperLayer !== null) {
      var oldHelperNumberLayer = oldReferenceLayer.querySelector(&quot;.introjs-helperNumberLayer&quot;);
      var oldtooltipLayer = oldReferenceLayer.querySelector(&quot;.introjs-tooltiptext&quot;);
      var oldTooltipTitleLayer = oldReferenceLayer.querySelector(&quot;.introjs-tooltip-title&quot;);
      var oldArrowLayer = oldReferenceLayer.querySelector(&quot;.introjs-arrow&quot;);
      var oldtooltipContainer = oldReferenceLayer.querySelector(&quot;.introjs-tooltip&quot;);
      skipTooltipButton = oldReferenceLayer.querySelector(&quot;.introjs-skipbutton&quot;);
      prevTooltipButton = oldReferenceLayer.querySelector(&quot;.introjs-prevbutton&quot;);
      nextTooltipButton = oldReferenceLayer.querySelector(&quot;.introjs-nextbutton&quot;); //update or reset the helper highlight class

      oldHelperLayer.className = highlightClass; //hide the tooltip

      oldtooltipContainer.style.opacity = 0;
      oldtooltipContainer.style.display = &quot;none&quot;; // if the target element is within a scrollable element

      scrollParentToElement.call(self, targetElement); // set new position to helper layer

      setHelperLayerPosition.call(self, oldHelperLayer);
      setHelperLayerPosition.call(self, oldReferenceLayer); //remove old classes if the element still exist

      removeShowElement(); //we should wait until the CSS3 transition is competed (it&apos;s 0.3 sec) to prevent incorrect `height` and `width` calculation

      if (self._lastShowElementTimer) {
        window.clearTimeout(self._lastShowElementTimer);
      }

      self._lastShowElementTimer = window.setTimeout(function () {
        // set current step to the label
        if (oldHelperNumberLayer !== null) {
          oldHelperNumberLayer.innerHTML = &quot;&quot;.concat(targetElement.step, &quot; of &quot;).concat(_this._introItems.length);
        } // set current tooltip text


        oldtooltipLayer.innerHTML = targetElement.intro; // set current tooltip title

        oldTooltipTitleLayer.innerHTML = targetElement.title; //set the tooltip position

        oldtooltipContainer.style.display = &quot;block&quot;;
        placeTooltip.call(self, targetElement.element, oldtooltipContainer, oldArrowLayer); //change active bullet

        if (self._options.showBullets) {
          oldReferenceLayer.querySelector(&quot;.introjs-bullets li &gt; a.active&quot;).className = &quot;&quot;;
          oldReferenceLayer.querySelector(&quot;.introjs-bullets li &gt; a[data-stepnumber=\&quot;&quot;.concat(targetElement.step, &quot;\&quot;]&quot;)).className = &quot;active&quot;;
        }

        oldReferenceLayer.querySelector(&quot;.introjs-progress .introjs-progressbar&quot;).style.cssText = &quot;width:&quot;.concat(_getProgress.call(self), &quot;%;&quot;);
        oldReferenceLayer.querySelector(&quot;.introjs-progress .introjs-progressbar&quot;).setAttribute(&quot;aria-valuenow&quot;, _getProgress.call(self)); //show the tooltip

        oldtooltipContainer.style.opacity = 1; //reset button focus

        if (typeof nextTooltipButton !== &quot;undefined&quot; &amp;&amp; nextTooltipButton !== null &amp;&amp; /introjs-donebutton/gi.test(nextTooltipButton.className)) {
          // skip button is now &quot;done&quot; button
          nextTooltipButton.focus();
        } else if (typeof nextTooltipButton !== &quot;undefined&quot; &amp;&amp; nextTooltipButton !== null) {
          //still in the tour, focus on next
          nextTooltipButton.focus();
        } // change the scroll of the window, if needed


        scrollTo.call(self, targetElement.scrollTo, targetElement, oldtooltipLayer);
      }, 350); // end of old element if-else condition
    } else {
      var helperLayer = _createElement(&quot;div&quot;, {
        className: highlightClass
      });
      var referenceLayer = _createElement(&quot;div&quot;, {
        className: &quot;introjs-tooltipReferenceLayer&quot;
      });
      var arrowLayer = _createElement(&quot;div&quot;, {
        className: &quot;introjs-arrow&quot;
      });
      var tooltipLayer = _createElement(&quot;div&quot;, {
        className: &quot;introjs-tooltip&quot;
      });
      var tooltipTextLayer = _createElement(&quot;div&quot;, {
        className: &quot;introjs-tooltiptext&quot;
      });
      var tooltipHeaderLayer = _createElement(&quot;div&quot;, {
        className: &quot;introjs-tooltip-header&quot;
      });
      var tooltipTitleLayer = _createElement(&quot;h1&quot;, {
        className: &quot;introjs-tooltip-title&quot;
      });
      var bulletsLayer = _createElement(&quot;div&quot;, {
        className: &quot;introjs-bullets&quot;
      });
      var progressLayer = _createElement(&quot;div&quot;);
      var buttonsLayer = _createElement(&quot;div&quot;);
      setStyle(helperLayer, {
        &quot;box-shadow&quot;: &quot;0 0 1px 2px rgba(33, 33, 33, 0.8), rgba(33, 33, 33, &quot;.concat(self._options.overlayOpacity.toString(), &quot;) 0 0 0 5000px&quot;)
      }); // target is within a scrollable element

      scrollParentToElement.call(self, targetElement); //set new position to helper layer

      setHelperLayerPosition.call(self, helperLayer);
      setHelperLayerPosition.call(self, referenceLayer); //add helper layer to target element

      appendChild(this._targetElement, helperLayer, true);
      appendChild(this._targetElement, referenceLayer);
      tooltipTextLayer.innerHTML = targetElement.intro;
      tooltipTitleLayer.innerHTML = targetElement.title;

      if (this._options.showBullets === false) {
        bulletsLayer.style.display = &quot;none&quot;;
      }

      var ulContainer = _createElement(&quot;ul&quot;);
      ulContainer.setAttribute(&quot;role&quot;, &quot;tablist&quot;);

      var anchorClick = function anchorClick() {
        self.goToStep(this.getAttribute(&quot;data-stepnumber&quot;));
      };

      forEach(this._introItems, function (_ref, i) {
        var step = _ref.step;
        var innerLi = _createElement(&quot;li&quot;);
        var anchorLink = _createElement(&quot;a&quot;);
        innerLi.setAttribute(&quot;role&quot;, &quot;presentation&quot;);
        anchorLink.setAttribute(&quot;role&quot;, &quot;tab&quot;);
        anchorLink.onclick = anchorClick;

        if (i === targetElement.step - 1) {
          anchorLink.className = &quot;active&quot;;
        }

        setAnchorAsButton(anchorLink);
        anchorLink.innerHTML = &quot;&amp;nbsp;&quot;;
        anchorLink.setAttribute(&quot;data-stepnumber&quot;, step);
        innerLi.appendChild(anchorLink);
        ulContainer.appendChild(innerLi);
      });
      bulletsLayer.appendChild(ulContainer);
      progressLayer.className = &quot;introjs-progress&quot;;

      if (this._options.showProgress === false) {
        progressLayer.style.display = &quot;none&quot;;
      }

      var progressBar = _createElement(&quot;div&quot;, {
        className: &quot;introjs-progressbar&quot;
      });

      if (this._options.progressBarAdditionalClass) {
        progressBar.className += &quot; &quot; + this._options.progressBarAdditionalClass;
      }

      progressBar.setAttribute(&quot;role&quot;, &quot;progress&quot;);
      progressBar.setAttribute(&quot;aria-valuemin&quot;, 0);
      progressBar.setAttribute(&quot;aria-valuemax&quot;, 100);
      progressBar.setAttribute(&quot;aria-valuenow&quot;, _getProgress.call(this));
      progressBar.style.cssText = &quot;width:&quot;.concat(_getProgress.call(this), &quot;%;&quot;);
      progressLayer.appendChild(progressBar);
      buttonsLayer.className = &quot;introjs-tooltipbuttons&quot;;

      if (this._options.showButtons === false) {
        buttonsLayer.style.display = &quot;none&quot;;
      }

      tooltipHeaderLayer.appendChild(tooltipTitleLayer);
      tooltipLayer.appendChild(tooltipHeaderLayer);
      tooltipLayer.appendChild(tooltipTextLayer);
      tooltipLayer.appendChild(bulletsLayer);
      tooltipLayer.appendChild(progressLayer); // add helper layer number

      var helperNumberLayer = _createElement(&quot;div&quot;);

      if (this._options.showStepNumbers === true) {
        helperNumberLayer.className = &quot;introjs-helperNumberLayer&quot;;
        helperNumberLayer.innerHTML = &quot;&quot;.concat(targetElement.step, &quot; of &quot;).concat(this._introItems.length);
        tooltipLayer.appendChild(helperNumberLayer);
      }

      tooltipLayer.appendChild(arrowLayer);
      referenceLayer.appendChild(tooltipLayer); //next button

      nextTooltipButton = _createElement(&quot;a&quot;);

      nextTooltipButton.onclick = function () {
        if (self._introItems.length - 1 !== self._currentStep) {
          nextStep.call(self);
        } else if (/introjs-donebutton/gi.test(nextTooltipButton.className)) {
          if (typeof self._introCompleteCallback === &quot;function&quot;) {
            self._introCompleteCallback.call(self);
          }

          exitIntro.call(self, self._targetElement);
        }
      };

      setAnchorAsButton(nextTooltipButton);
      nextTooltipButton.innerHTML = this._options.nextLabel; //previous button

      prevTooltipButton = _createElement(&quot;a&quot;);

      prevTooltipButton.onclick = function () {
        if (self._currentStep !== 0) {
          previousStep.call(self);
        }
      };

      setAnchorAsButton(prevTooltipButton);
      prevTooltipButton.innerHTML = this._options.prevLabel; //skip button

      skipTooltipButton = _createElement(&quot;a&quot;, {
        className: &quot;introjs-skipbutton&quot;
      });
      setAnchorAsButton(skipTooltipButton);
      skipTooltipButton.innerHTML = this._options.skipLabel;

      skipTooltipButton.onclick = function () {
        if (self._introItems.length - 1 === self._currentStep &amp;&amp; typeof self._introCompleteCallback === &quot;function&quot;) {
          self._introCompleteCallback.call(self);
        }

        if (typeof self._introSkipCallback === &quot;function&quot;) {
          self._introSkipCallback.call(self);
        }

        exitIntro.call(self, self._targetElement);
      };

      tooltipHeaderLayer.appendChild(skipTooltipButton); //in order to prevent displaying previous button always

      if (this._introItems.length &gt; 1) {
        buttonsLayer.appendChild(prevTooltipButton);
      } // we always need the next button because this
      // button changes to &quot;Done&quot; in the last step of the tour


      buttonsLayer.appendChild(nextTooltipButton);
      tooltipLayer.appendChild(buttonsLayer); //set proper position

      placeTooltip.call(self, targetElement.element, tooltipLayer, arrowLayer); // change the scroll of the window, if needed

      scrollTo.call(this, targetElement.scrollTo, targetElement, tooltipLayer); //end of new element if-else condition
    } // removing previous disable interaction layer


    var disableInteractionLayer = self._targetElement.querySelector(&quot;.introjs-disableInteraction&quot;);

    if (disableInteractionLayer) {
      disableInteractionLayer.parentNode.removeChild(disableInteractionLayer);
    } //disable interaction


    if (targetElement.disableInteraction) {
      _disableInteraction.call(self);
    } // when it&apos;s the first step of tour


    if (this._currentStep === 0 &amp;&amp; this._introItems.length &gt; 1) {
      if (typeof nextTooltipButton !== &quot;undefined&quot; &amp;&amp; nextTooltipButton !== null) {
        nextTooltipButton.className = &quot;&quot;.concat(this._options.buttonClass, &quot; introjs-nextbutton&quot;);
        nextTooltipButton.innerHTML = this._options.nextLabel;
      }

      if (this._options.hidePrev === true) {
        if (typeof prevTooltipButton !== &quot;undefined&quot; &amp;&amp; prevTooltipButton !== null) {
          prevTooltipButton.className = &quot;&quot;.concat(this._options.buttonClass, &quot; introjs-prevbutton introjs-hidden&quot;);
        }

        if (typeof nextTooltipButton !== &quot;undefined&quot; &amp;&amp; nextTooltipButton !== null) {
          addClass(nextTooltipButton, &quot;introjs-fullbutton&quot;);
        }
      } else {
        if (typeof prevTooltipButton !== &quot;undefined&quot; &amp;&amp; prevTooltipButton !== null) {
          prevTooltipButton.className = &quot;&quot;.concat(this._options.buttonClass, &quot; introjs-prevbutton introjs-disabled&quot;);
        }
      }
    } else if (this._introItems.length - 1 === this._currentStep || this._introItems.length === 1) {
      // last step of tour
      if (typeof prevTooltipButton !== &quot;undefined&quot; &amp;&amp; prevTooltipButton !== null) {
        prevTooltipButton.className = &quot;&quot;.concat(this._options.buttonClass, &quot; introjs-prevbutton&quot;);
      }

      if (this._options.hideNext === true) {
        if (typeof nextTooltipButton !== &quot;undefined&quot; &amp;&amp; nextTooltipButton !== null) {
          nextTooltipButton.className = &quot;&quot;.concat(this._options.buttonClass, &quot; introjs-nextbutton introjs-hidden&quot;);
        }

        if (typeof prevTooltipButton !== &quot;undefined&quot; &amp;&amp; prevTooltipButton !== null) {
          addClass(prevTooltipButton, &quot;introjs-fullbutton&quot;);
        }
      } else {
        if (typeof nextTooltipButton !== &quot;undefined&quot; &amp;&amp; nextTooltipButton !== null) {
          if (this._options.nextToDone === true) {
            nextTooltipButton.innerHTML = this._options.doneLabel;
            addClass(nextTooltipButton, &quot;&quot;.concat(this._options.buttonClass, &quot; introjs-nextbutton introjs-donebutton&quot;));
          } else {
            nextTooltipButton.className = &quot;&quot;.concat(this._options.buttonClass, &quot; introjs-nextbutton introjs-disabled&quot;);
          }
        }
      }
    } else {
      // steps between start and end
      if (typeof prevTooltipButton !== &quot;undefined&quot; &amp;&amp; prevTooltipButton !== null) {
        prevTooltipButton.className = &quot;&quot;.concat(this._options.buttonClass, &quot; introjs-prevbutton&quot;);
      }

      if (typeof nextTooltipButton !== &quot;undefined&quot; &amp;&amp; nextTooltipButton !== null) {
        nextTooltipButton.className = &quot;&quot;.concat(this._options.buttonClass, &quot; introjs-nextbutton&quot;);
        nextTooltipButton.innerHTML = this._options.nextLabel;
      }
    }

    if (typeof prevTooltipButton !== &quot;undefined&quot; &amp;&amp; prevTooltipButton !== null) {
      prevTooltipButton.setAttribute(&quot;role&quot;, &quot;button&quot;);
    }

    if (typeof nextTooltipButton !== &quot;undefined&quot; &amp;&amp; nextTooltipButton !== null) {
      nextTooltipButton.setAttribute(&quot;role&quot;, &quot;button&quot;);
    }

    if (typeof skipTooltipButton !== &quot;undefined&quot; &amp;&amp; skipTooltipButton !== null) {
      skipTooltipButton.setAttribute(&quot;role&quot;, &quot;button&quot;);
    } //Set focus on &quot;next&quot; button, so that hitting Enter always moves you onto the next step


    if (typeof nextTooltipButton !== &quot;undefined&quot; &amp;&amp; nextTooltipButton !== null) {
      nextTooltipButton.focus();
    }

    setShowElement(targetElement);

    if (typeof this._introAfterChangeCallback !== &quot;undefined&quot;) {
      this._introAfterChangeCallback.call(this, targetElement.element);
    }
  }

  /**
   * Go to specific step of introduction
   *
   * @api private
   * @method _goToStep
   */

  function goToStep(step) {
    //because steps starts with zero
    this._currentStep = step - 2;

    if (typeof this._introItems !== &quot;undefined&quot;) {
      nextStep.call(this);
    }
  }
  /**
   * Go to the specific step of introduction with the explicit [data-step] number
   *
   * @api private
   * @method _goToStepNumber
   */

  function goToStepNumber(step) {
    this._currentStepNumber = step;

    if (typeof this._introItems !== &quot;undefined&quot;) {
      nextStep.call(this);
    }
  }
  /**
   * Go to next step on intro
   *
   * @api private
   * @method _nextStep
   */

  function nextStep() {
    var _this = this;

    this._direction = &quot;forward&quot;;

    if (typeof this._currentStepNumber !== &quot;undefined&quot;) {
      forEach(this._introItems, function (_ref, i) {
        var step = _ref.step;

        if (step === _this._currentStepNumber) {
          _this._currentStep = i - 1;
          _this._currentStepNumber = undefined;
        }
      });
    }

    if (typeof this._currentStep === &quot;undefined&quot;) {
      this._currentStep = 0;
    } else {
      ++this._currentStep;
    }

    var nextStep = this._introItems[this._currentStep];
    var continueStep = true;

    if (typeof this._introBeforeChangeCallback !== &quot;undefined&quot;) {
      continueStep = this._introBeforeChangeCallback.call(this, nextStep &amp;&amp; nextStep.element);
    } // if `onbeforechange` returned `false`, stop displaying the element


    if (continueStep === false) {
      --this._currentStep;
      return false;
    }

    if (this._introItems.length &lt;= this._currentStep) {
      //end of the intro
      //check if any callback is defined
      if (typeof this._introCompleteCallback === &quot;function&quot;) {
        this._introCompleteCallback.call(this);
      }

      exitIntro.call(this, this._targetElement);
      return;
    }

    _showElement.call(this, nextStep);
  }
  /**
   * Go to previous step on intro
   *
   * @api private
   * @method _previousStep
   */

  function previousStep() {
    this._direction = &quot;backward&quot;;

    if (this._currentStep === 0) {
      return false;
    }

    --this._currentStep;
    var nextStep = this._introItems[this._currentStep];
    var continueStep = true;

    if (typeof this._introBeforeChangeCallback !== &quot;undefined&quot;) {
      continueStep = this._introBeforeChangeCallback.call(this, nextStep &amp;&amp; nextStep.element);
    } // if `onbeforechange` returned `false`, stop displaying the element


    if (continueStep === false) {
      ++this._currentStep;
      return false;
    }

    _showElement.call(this, nextStep);
  }
  /**
   * Returns the current step of the intro
   *
   * @returns {number | boolean}
   */

  function currentStep() {
    return this._currentStep;
  }

  /**
   * on keyCode:
   * https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode
   * This feature has been removed from the Web standards.
   * Though some browsers may still support it, it is in
   * the process of being dropped.
   * Instead, you should use KeyboardEvent.code,
   * if it&apos;s implemented.
   *
   * jQuery&apos;s approach is to test for
   *   (1) e.which, then
   *   (2) e.charCode, then
   *   (3) e.keyCode
   * https://github.com/jquery/jquery/blob/a6b0705294d336ae2f63f7276de0da1195495363/src/event.js#L638
   *
   * @param type var
   * @return type
   */

  function onKeyDown(e) {
    var code = e.code === undefined ? e.which : e.code; // if e.which is null

    if (code === null) {
      code = e.charCode === null ? e.keyCode : e.charCode;
    }

    if ((code === &quot;Escape&quot; || code === 27) &amp;&amp; this._options.exitOnEsc === true) {
      //escape key pressed, exit the intro
      //check if exit callback is defined
      exitIntro.call(this, this._targetElement);
    } else if (code === &quot;ArrowLeft&quot; || code === 37) {
      //left arrow
      previousStep.call(this);
    } else if (code === &quot;ArrowRight&quot; || code === 39) {
      //right arrow
      nextStep.call(this);
    } else if (code === &quot;Enter&quot; || code === &quot;NumpadEnter&quot; || code === 13) {
      //srcElement === ie
      var target = e.target || e.srcElement;

      if (target &amp;&amp; target.className.match(&quot;introjs-prevbutton&quot;)) {
        //user hit enter while focusing on previous button
        previousStep.call(this);
      } else if (target &amp;&amp; target.className.match(&quot;introjs-skipbutton&quot;)) {
        //user hit enter while focusing on skip button
        if (this._introItems.length - 1 === this._currentStep &amp;&amp; typeof this._introCompleteCallback === &quot;function&quot;) {
          this._introCompleteCallback.call(this);
        }

        exitIntro.call(this, this._targetElement);
      } else if (target &amp;&amp; target.getAttribute(&quot;data-stepnumber&quot;)) {
        // user hit enter while focusing on step bullet
        target.click();
      } else {
        //default behavior for responding to enter
        nextStep.call(this);
      } //prevent default behaviour on hitting Enter, to prevent steps being skipped in some browsers


      if (e.preventDefault) {
        e.preventDefault();
      } else {
        e.returnValue = false;
      }
    }
  }

  /*
   * makes a copy of the object
   * @api private
   * @method _cloneObject
   */
  function cloneObject(object) {
    if (object === null || _typeof(object) !== &quot;object&quot; || typeof object.nodeType !== &quot;undefined&quot;) {
      return object;
    }

    var temp = {};

    for (var key in object) {
      if (typeof window.jQuery !== &quot;undefined&quot; &amp;&amp; object[key] instanceof window.jQuery) {
        temp[key] = object[key];
      } else {
        temp[key] = cloneObject(object[key]);
      }
    }

    return temp;
  }

  /**
   * Get a queryselector within the hint wrapper
   *
   * @param {String} selector
   * @return {NodeList|Array}
   */

  function hintQuerySelectorAll(selector) {
    var hintsWrapper = document.querySelector(&quot;.introjs-hints&quot;);
    return hintsWrapper ? hintsWrapper.querySelectorAll(selector) : [];
  }
  /**
   * Hide a hint
   *
   * @api private
   * @method hideHint
   */

  function hideHint(stepId) {
    var hint = hintQuerySelectorAll(&quot;.introjs-hint[data-step=\&quot;&quot;.concat(stepId, &quot;\&quot;]&quot;))[0];
    removeHintTooltip.call(this);

    if (hint) {
      addClass(hint, &quot;introjs-hidehint&quot;);
    } // call the callback function (if any)


    if (typeof this._hintCloseCallback !== &quot;undefined&quot;) {
      this._hintCloseCallback.call(this, stepId);
    }
  }
  /**
   * Hide all hints
   *
   * @api private
   * @method hideHints
   */

  function hideHints() {
    var _this = this;

    var hints = hintQuerySelectorAll(&quot;.introjs-hint&quot;);
    forEach(hints, function (hint) {
      hideHint.call(_this, hint.getAttribute(&quot;data-step&quot;));
    });
  }
  /**
   * Show all hints
   *
   * @api private
   * @method _showHints
   */

  function showHints() {
    var _this2 = this;

    var hints = hintQuerySelectorAll(&quot;.introjs-hint&quot;);

    if (hints &amp;&amp; hints.length) {
      forEach(hints, function (hint) {
        showHint.call(_this2, hint.getAttribute(&quot;data-step&quot;));
      });
    } else {
      populateHints.call(this, this._targetElement);
    }
  }
  /**
   * Show a hint
   *
   * @api private
   * @method showHint
   */

  function showHint(stepId) {
    var hint = hintQuerySelectorAll(&quot;.introjs-hint[data-step=\&quot;&quot;.concat(stepId, &quot;\&quot;]&quot;))[0];

    if (hint) {
      removeClass(hint, /introjs-hidehint/g);
    }
  }
  /**
   * Removes all hint elements on the page
   * Useful when you want to destroy the elements and add them again (e.g. a modal or popup)
   *
   * @api private
   * @method removeHints
   */

  function removeHints() {
    var _this3 = this;

    var hints = hintQuerySelectorAll(&quot;.introjs-hint&quot;);
    forEach(hints, function (hint) {
      removeHint.call(_this3, hint.getAttribute(&quot;data-step&quot;));
    });
  }
  /**
   * Remove one single hint element from the page
   * Useful when you want to destroy the element and add them again (e.g. a modal or popup)
   * Use removeHints if you want to remove all elements.
   *
   * @api private
   * @method removeHint
   */

  function removeHint(stepId) {
    var hint = hintQuerySelectorAll(&quot;.introjs-hint[data-step=\&quot;&quot;.concat(stepId, &quot;\&quot;]&quot;))[0];

    if (hint) {
      hint.parentNode.removeChild(hint);
    }
  }
  /**
   * Add all available hints to the page
   *
   * @api private
   * @method addHints
   */

  function addHints() {
    var _this4 = this;

    var self = this;
    var hintsWrapper = document.querySelector(&quot;.introjs-hints&quot;);

    if (hintsWrapper === null) {
      hintsWrapper = _createElement(&quot;div&quot;, {
        className: &quot;introjs-hints&quot;
      });
    }
    /**
     * Returns an event handler unique to the hint iteration
     *
     * @param {Integer} i
     * @return {Function}
     */


    var getHintClick = function getHintClick(i) {
      return function (e) {
        var evt = e ? e : window.event;

        if (evt.stopPropagation) {
          evt.stopPropagation();
        }

        if (evt.cancelBubble !== null) {
          evt.cancelBubble = true;
        }

        showHintDialog.call(self, i);
      };
    };

    forEach(this._introItems, function (item, i) {
      // avoid append a hint twice
      if (document.querySelector(&quot;.introjs-hint[data-step=\&quot;&quot;.concat(i, &quot;\&quot;]&quot;))) {
        return;
      }

      var hint = _createElement(&quot;a&quot;, {
        className: &quot;introjs-hint&quot;
      });
      setAnchorAsButton(hint);
      hint.onclick = getHintClick(i);

      if (!item.hintAnimation) {
        addClass(hint, &quot;introjs-hint-no-anim&quot;);
      } // hint&apos;s position should be fixed if the target element&apos;s position is fixed


      if (isFixed(item.element)) {
        addClass(hint, &quot;introjs-fixedhint&quot;);
      }

      var hintDot = _createElement(&quot;div&quot;, {
        className: &quot;introjs-hint-dot&quot;
      });
      var hintPulse = _createElement(&quot;div&quot;, {
        className: &quot;introjs-hint-pulse&quot;
      });
      hint.appendChild(hintDot);
      hint.appendChild(hintPulse);
      hint.setAttribute(&quot;data-step&quot;, i); // we swap the hint element with target element
      // because _setHelperLayerPosition uses `element` property

      item.targetElement = item.element;
      item.element = hint; // align the hint position

      alignHintPosition.call(_this4, item.hintPosition, hint, item.targetElement);
      hintsWrapper.appendChild(hint);
    }); // adding the hints wrapper

    document.body.appendChild(hintsWrapper); // call the callback function (if any)

    if (typeof this._hintsAddedCallback !== &quot;undefined&quot;) {
      this._hintsAddedCallback.call(this);
    }
  }
  /**
   * Aligns hint position
   *
   * @api private
   * @method alignHintPosition
   * @param {String} position
   * @param {Object} hint
   * @param {Object} element
   */

  function alignHintPosition(position, _ref, element) {
    var style = _ref.style;
    // get/calculate offset of target element
    var offset = getOffset.call(this, element);
    var iconWidth = 20;
    var iconHeight = 20; // align the hint element

    switch (position) {
      default:
      case &quot;top-left&quot;:
        style.left = &quot;&quot;.concat(offset.left, &quot;px&quot;);
        style.top = &quot;&quot;.concat(offset.top, &quot;px&quot;);
        break;

      case &quot;top-right&quot;:
        style.left = &quot;&quot;.concat(offset.left + offset.width - iconWidth, &quot;px&quot;);
        style.top = &quot;&quot;.concat(offset.top, &quot;px&quot;);
        break;

      case &quot;bottom-left&quot;:
        style.left = &quot;&quot;.concat(offset.left, &quot;px&quot;);
        style.top = &quot;&quot;.concat(offset.top + offset.height - iconHeight, &quot;px&quot;);
        break;

      case &quot;bottom-right&quot;:
        style.left = &quot;&quot;.concat(offset.left + offset.width - iconWidth, &quot;px&quot;);
        style.top = &quot;&quot;.concat(offset.top + offset.height - iconHeight, &quot;px&quot;);
        break;

      case &quot;middle-left&quot;:
        style.left = &quot;&quot;.concat(offset.left, &quot;px&quot;);
        style.top = &quot;&quot;.concat(offset.top + (offset.height - iconHeight) / 2, &quot;px&quot;);
        break;

      case &quot;middle-right&quot;:
        style.left = &quot;&quot;.concat(offset.left + offset.width - iconWidth, &quot;px&quot;);
        style.top = &quot;&quot;.concat(offset.top + (offset.height - iconHeight) / 2, &quot;px&quot;);
        break;

      case &quot;middle-middle&quot;:
        style.left = &quot;&quot;.concat(offset.left + (offset.width - iconWidth) / 2, &quot;px&quot;);
        style.top = &quot;&quot;.concat(offset.top + (offset.height - iconHeight) / 2, &quot;px&quot;);
        break;

      case &quot;bottom-middle&quot;:
        style.left = &quot;&quot;.concat(offset.left + (offset.width - iconWidth) / 2, &quot;px&quot;);
        style.top = &quot;&quot;.concat(offset.top + offset.height - iconHeight, &quot;px&quot;);
        break;

      case &quot;top-middle&quot;:
        style.left = &quot;&quot;.concat(offset.left + (offset.width - iconWidth) / 2, &quot;px&quot;);
        style.top = &quot;&quot;.concat(offset.top, &quot;px&quot;);
        break;
    }
  }
  /**
   * Triggers when user clicks on the hint element
   *
   * @api private
   * @method _showHintDialog
   * @param {Number} stepId
   */

  function showHintDialog(stepId) {
    var hintElement = document.querySelector(&quot;.introjs-hint[data-step=\&quot;&quot;.concat(stepId, &quot;\&quot;]&quot;));
    var item = this._introItems[stepId]; // call the callback function (if any)

    if (typeof this._hintClickCallback !== &quot;undefined&quot;) {
      this._hintClickCallback.call(this, hintElement, item, stepId);
    } // remove all open tooltips


    var removedStep = removeHintTooltip.call(this); // to toggle the tooltip

    if (parseInt(removedStep, 10) === stepId) {
      return;
    }

    var tooltipLayer = _createElement(&quot;div&quot;, {
      className: &quot;introjs-tooltip&quot;
    });
    var tooltipTextLayer = _createElement(&quot;div&quot;);
    var arrowLayer = _createElement(&quot;div&quot;);
    var referenceLayer = _createElement(&quot;div&quot;);

    tooltipLayer.onclick = function (e) {
      //IE9 &amp; Other Browsers
      if (e.stopPropagation) {
        e.stopPropagation();
      } //IE8 and Lower
      else {
          e.cancelBubble = true;
        }
    };

    tooltipTextLayer.className = &quot;introjs-tooltiptext&quot;;
    var tooltipWrapper = _createElement(&quot;p&quot;);
    tooltipWrapper.innerHTML = item.hint;
    var closeButton = _createElement(&quot;a&quot;);
    closeButton.className = this._options.buttonClass;
    closeButton.setAttribute(&quot;role&quot;, &quot;button&quot;);
    closeButton.innerHTML = this._options.hintButtonLabel;
    closeButton.onclick = hideHint.bind(this, stepId);
    tooltipTextLayer.appendChild(tooltipWrapper);
    tooltipTextLayer.appendChild(closeButton);
    arrowLayer.className = &quot;introjs-arrow&quot;;
    tooltipLayer.appendChild(arrowLayer);
    tooltipLayer.appendChild(tooltipTextLayer); // set current step for _placeTooltip function

    this._currentStep = hintElement.getAttribute(&quot;data-step&quot;); // align reference layer position

    referenceLayer.className = &quot;introjs-tooltipReferenceLayer introjs-hintReference&quot;;
    referenceLayer.setAttribute(&quot;data-step&quot;, hintElement.getAttribute(&quot;data-step&quot;));
    setHelperLayerPosition.call(this, referenceLayer);
    referenceLayer.appendChild(tooltipLayer);
    document.body.appendChild(referenceLayer); //set proper position

    placeTooltip.call(this, hintElement, tooltipLayer, arrowLayer, true);
  }
  /**
   * Removes open hint (tooltip hint)
   *
   * @api private
   * @method _removeHintTooltip
   */

  function removeHintTooltip() {
    var tooltip = document.querySelector(&quot;.introjs-hintReference&quot;);

    if (tooltip) {
      var step = tooltip.getAttribute(&quot;data-step&quot;);
      tooltip.parentNode.removeChild(tooltip);
      return step;
    }
  }
  /**
   * Start parsing hint items
   *
   * @api private
   * @param {Object} targetElm
   * @method _startHint
   */

  function populateHints(targetElm) {
    var _this5 = this;

    this._introItems = [];

    if (this._options.hints) {
      forEach(this._options.hints, function (hint) {
        var currentItem = cloneObject(hint);

        if (typeof currentItem.element === &quot;string&quot;) {
          //grab the element with given selector from the page
          currentItem.element = document.querySelector(currentItem.element);
        }

        currentItem.hintPosition = currentItem.hintPosition || _this5._options.hintPosition;
        currentItem.hintAnimation = currentItem.hintAnimation || _this5._options.hintAnimation;

        if (currentItem.element !== null) {
          _this5._introItems.push(currentItem);
        }
      });
    } else {
      var hints = targetElm.querySelectorAll(&quot;*[data-hint]&quot;);

      if (!hints || !hints.length) {
        return false;
      } //first add intro items with data-step


      forEach(hints, function (currentElement) {
        // hint animation
        var hintAnimation = currentElement.getAttribute(&quot;data-hintanimation&quot;);

        if (hintAnimation) {
          hintAnimation = hintAnimation === &quot;true&quot;;
        } else {
          hintAnimation = _this5._options.hintAnimation;
        }

        _this5._introItems.push({
          element: currentElement,
          hint: currentElement.getAttribute(&quot;data-hint&quot;),
          hintPosition: currentElement.getAttribute(&quot;data-hintposition&quot;) || _this5._options.hintPosition,
          hintAnimation: hintAnimation,
          tooltipClass: currentElement.getAttribute(&quot;data-tooltipclass&quot;),
          position: currentElement.getAttribute(&quot;data-position&quot;) || _this5._options.tooltipPosition
        });
      });
    }

    addHints.call(this);
    /*
    todo:
    these events should be removed at some point
    */

    DOMEvent.on(document, &quot;click&quot;, removeHintTooltip, this, false);
    DOMEvent.on(window, &quot;resize&quot;, reAlignHints, this, true);
  }
  /**
   * Re-aligns all hint elements
   *
   * @api private
   * @method _reAlignHints
   */

  function reAlignHints() {
    var _this6 = this;

    forEach(this._introItems, function (_ref2) {
      var targetElement = _ref2.targetElement,
          hintPosition = _ref2.hintPosition,
          element = _ref2.element;

      if (typeof targetElement === &quot;undefined&quot;) {
        return;
      }

      alignHintPosition.call(_this6, hintPosition, element, targetElement);
    });
  }

  /**
   * Update placement of the intro objects on the screen
   * @api private
   */

  function refresh() {
    // re-align intros
    setHelperLayerPosition.call(this, document.querySelector(&quot;.introjs-helperLayer&quot;));
    setHelperLayerPosition.call(this, document.querySelector(&quot;.introjs-tooltipReferenceLayer&quot;));
    setHelperLayerPosition.call(this, document.querySelector(&quot;.introjs-disableInteraction&quot;)); // re-align tooltip

    if (this._currentStep !== undefined &amp;&amp; this._currentStep !== null) {
      var oldArrowLayer = document.querySelector(&quot;.introjs-arrow&quot;);
      var oldtooltipContainer = document.querySelector(&quot;.introjs-tooltip&quot;);
      placeTooltip.call(this, this._introItems[this._currentStep].element, oldtooltipContainer, oldArrowLayer);
    } //re-align hints


    reAlignHints.call(this);
    return this;
  }

  function onResize() {
    refresh.call(this);
  }

  /**
   * Removes `element` from `parentElement`
   *
   * @param {Element} element
   * @param {Boolean} [animate=false]
   */

  function removeChild(element, animate) {
    if (!element || !element.parentElement) return;
    var parentElement = element.parentElement;

    if (animate) {
      setStyle(element, {
        opacity: &quot;0&quot;
      });
      window.setTimeout(function () {
        parentElement.removeChild(element);
      }, 500);
    } else {
      parentElement.removeChild(element);
    }
  }

  /**
   * Exit from intro
   *
   * @api private
   * @method _exitIntro
   * @param {Object} targetElement
   * @param {Boolean} force - Setting to `true` will skip the result of beforeExit callback
   */

  function exitIntro(targetElement, force) {
    var continueExit = true; // calling onbeforeexit callback
    //
    // If this callback return `false`, it would halt the process

    if (this._introBeforeExitCallback !== undefined) {
      continueExit = this._introBeforeExitCallback.call(this);
    } // skip this check if `force` parameter is `true`
    // otherwise, if `onbeforeexit` returned `false`, don&apos;t exit the intro


    if (!force &amp;&amp; continueExit === false) return; // remove overlay layers from the page

    var overlayLayers = targetElement.querySelectorAll(&quot;.introjs-overlay&quot;);

    if (overlayLayers &amp;&amp; overlayLayers.length) {
      forEach(overlayLayers, function (overlayLayer) {
        return removeChild(overlayLayer);
      });
    } //remove all helper layers


    var helperLayer = targetElement.querySelector(&quot;.introjs-helperLayer&quot;);
    removeChild(helperLayer, true);
    var referenceLayer = targetElement.querySelector(&quot;.introjs-tooltipReferenceLayer&quot;);
    removeChild(referenceLayer); //remove disableInteractionLayer

    var disableInteractionLayer = targetElement.querySelector(&quot;.introjs-disableInteraction&quot;);
    removeChild(disableInteractionLayer); //remove intro floating element

    var floatingElement = document.querySelector(&quot;.introjsFloatingElement&quot;);
    removeChild(floatingElement);
    removeShowElement(); //clean listeners

    DOMEvent.off(window, &quot;keydown&quot;, onKeyDown, this, true);
    DOMEvent.off(window, &quot;resize&quot;, onResize, this, true); //check if any callback is defined

    if (this._introExitCallback !== undefined) {
      this._introExitCallback.call(this);
    } //set the step to zero


    this._currentStep = undefined;
  }

  /**
   * Add overlay layer to the page
   *
   * @api private
   * @method _addOverlayLayer
   * @param {Object} targetElm
   */

  function addOverlayLayer(targetElm) {
    var overlayLayer = _createElement(&quot;div&quot;, {
      className: &quot;introjs-overlay&quot;
    });
    var self = this; // check if the target element is body, we should calculate the size of overlay layer in a better way

    if (!targetElm.tagName || targetElm.tagName.toLowerCase() === &quot;body&quot;) {
      setStyle(overlayLayer, {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0,
        position: &quot;fixed&quot;
      });
    } else {
      // set overlay layer position
      var elementPosition = getOffset(targetElm);

      if (elementPosition) {
        setStyle(overlayLayer, {
          width: &quot;&quot;.concat(elementPosition.width, &quot;px&quot;),
          height: &quot;&quot;.concat(elementPosition.height, &quot;px&quot;),
          top: &quot;&quot;.concat(elementPosition.top, &quot;px&quot;),
          left: &quot;&quot;.concat(elementPosition.left, &quot;px&quot;)
        });
      }
    }

    targetElm.appendChild(overlayLayer);

    if (self._options.exitOnOverlayClick === true) {
      setStyle(overlayLayer, {
        cursor: &quot;pointer&quot;
      });

      overlayLayer.onclick = function () {
        exitIntro.call(self, targetElm);
      };
    }

    return true;
  }

  /**
   * Initiate a new introduction/guide from an element in the page
   *
   * @api private
   * @method _introForElement
   * @param {Object} targetElm
   * @param {String} group
   * @returns {Boolean} Success or not?
   */

  function introForElement(targetElm, group) {
    var _this = this;

    var allIntroSteps = targetElm.querySelectorAll(&quot;*[data-intro]&quot;);
    var introItems = [];

    if (this._options.steps) {
      //use steps passed programmatically
      forEach(this._options.steps, function (step) {
        var currentItem = cloneObject(step); //set the step

        currentItem.step = introItems.length + 1;
        currentItem.title = currentItem.title || &quot;&quot;; //use querySelector function only when developer used CSS selector

        if (typeof currentItem.element === &quot;string&quot;) {
          //grab the element with given selector from the page
          currentItem.element = document.querySelector(currentItem.element);
        } //intro without element


        if (typeof currentItem.element === &quot;undefined&quot; || currentItem.element === null) {
          var floatingElementQuery = document.querySelector(&quot;.introjsFloatingElement&quot;);

          if (floatingElementQuery === null) {
            floatingElementQuery = _createElement(&quot;div&quot;, {
              className: &quot;introjsFloatingElement&quot;
            });
            document.body.appendChild(floatingElementQuery);
          }

          currentItem.element = floatingElementQuery;
          currentItem.position = &quot;floating&quot;;
        }

        currentItem.scrollTo = currentItem.scrollTo || _this._options.scrollTo;

        if (typeof currentItem.disableInteraction === &quot;undefined&quot;) {
          currentItem.disableInteraction = _this._options.disableInteraction;
        }

        if (currentItem.element !== null) {
          introItems.push(currentItem);
        }
      });
    } else {
      //use steps from data-* annotations
      var elmsLength = allIntroSteps.length;
      var disableInteraction; //if there&apos;s no element to intro

      if (elmsLength &lt; 1) {
        return false;
      }

      forEach(allIntroSteps, function (currentElement) {
        // PR #80
        // start intro for groups of elements
        if (group &amp;&amp; currentElement.getAttribute(&quot;data-intro-group&quot;) !== group) {
          return;
        } // skip hidden elements


        if (currentElement.style.display === &quot;none&quot;) {
          return;
        }

        var step = parseInt(currentElement.getAttribute(&quot;data-step&quot;), 10);

        if (currentElement.hasAttribute(&quot;data-disable-interaction&quot;)) {
          disableInteraction = !!currentElement.getAttribute(&quot;data-disable-interaction&quot;);
        } else {
          disableInteraction = _this._options.disableInteraction;
        }

        if (step &gt; 0) {
          introItems[step - 1] = {
            element: currentElement,
            title: currentElement.getAttribute(&quot;data-title&quot;) || &quot;&quot;,
            intro: currentElement.getAttribute(&quot;data-intro&quot;),
            step: parseInt(currentElement.getAttribute(&quot;data-step&quot;), 10),
            tooltipClass: currentElement.getAttribute(&quot;data-tooltipclass&quot;),
            highlightClass: currentElement.getAttribute(&quot;data-highlightclass&quot;),
            position: currentElement.getAttribute(&quot;data-position&quot;) || _this._options.tooltipPosition,
            scrollTo: currentElement.getAttribute(&quot;data-scrollto&quot;) || _this._options.scrollTo,
            disableInteraction: disableInteraction
          };
        }
      }); //next add intro items without data-step
      //todo: we need a cleanup here, two loops are redundant

      var _nextStep = 0;
      forEach(allIntroSteps, function (currentElement) {
        // PR #80
        // start intro for groups of elements
        if (group &amp;&amp; currentElement.getAttribute(&quot;data-intro-group&quot;) !== group) {
          return;
        }

        if (currentElement.getAttribute(&quot;data-step&quot;) === null) {
          while (true) {
            if (typeof introItems[_nextStep] === &quot;undefined&quot;) {
              break;
            } else {
              _nextStep++;
            }
          }

          if (currentElement.hasAttribute(&quot;data-disable-interaction&quot;)) {
            disableInteraction = !!currentElement.getAttribute(&quot;data-disable-interaction&quot;);
          } else {
            disableInteraction = _this._options.disableInteraction;
          }

          introItems[_nextStep] = {
            element: currentElement,
            title: currentElement.getAttribute(&quot;data-title&quot;) || &quot;&quot;,
            intro: currentElement.getAttribute(&quot;data-intro&quot;),
            step: _nextStep + 1,
            tooltipClass: currentElement.getAttribute(&quot;data-tooltipclass&quot;),
            highlightClass: currentElement.getAttribute(&quot;data-highlightclass&quot;),
            position: currentElement.getAttribute(&quot;data-position&quot;) || _this._options.tooltipPosition,
            scrollTo: currentElement.getAttribute(&quot;data-scrollto&quot;) || _this._options.scrollTo,
            disableInteraction: disableInteraction
          };
        }
      });
    } //removing undefined/null elements


    var tempIntroItems = [];

    for (var z = 0; z &lt; introItems.length; z++) {
      if (introItems[z]) {
        // copy non-falsy values to the end of the array
        tempIntroItems.push(introItems[z]);
      }
    }

    introItems = tempIntroItems; //Ok, sort all items with given steps

    introItems.sort(function (a, b) {
      return a.step - b.step;
    }); //set it to the introJs object

    this._introItems = introItems; //add overlay layer to the page

    if (addOverlayLayer.call(this, targetElm)) {
      //then, start the show
      nextStep.call(this);

      if (this._options.keyboardNavigation) {
        DOMEvent.on(window, &quot;keydown&quot;, onKeyDown, this, true);
      } //for window resize


      DOMEvent.on(window, &quot;resize&quot;, onResize, this, true);
    }

    return false;
  }

  var version$1 = &quot;3.3.1&quot;;

  /**
   * IntroJs main class
   *
   * @class IntroJs
   */

  function IntroJs(obj) {
    this._targetElement = obj;
    this._introItems = [];
    this._options = {
      /* Next button label in tooltip box */
      nextLabel: &quot;Next&quot;,

      /* Previous button label in tooltip box */
      prevLabel: &quot;Back&quot;,

      /* Skip button label in tooltip box */
      skipLabel: &quot;&#xD7;&quot;,

      /* Done button label in tooltip box */
      doneLabel: &quot;Done&quot;,

      /* Hide previous button in the first step? Otherwise, it will be disabled button. */
      hidePrev: false,

      /* Hide next button in the last step? Otherwise, it will be disabled button (note: this will also hide the &quot;Done&quot; button) */
      hideNext: false,

      /* Change the Next button to Done in the last step of the intro? otherwise, it will render a disabled button */
      nextToDone: true,

      /* Default tooltip box position */
      tooltipPosition: &quot;bottom&quot;,

      /* Next CSS class for tooltip boxes */
      tooltipClass: &quot;&quot;,

      /* CSS class that is added to the helperLayer */
      highlightClass: &quot;&quot;,

      /* Close introduction when pressing Escape button? */
      exitOnEsc: true,

      /* Close introduction when clicking on overlay layer? */
      exitOnOverlayClick: true,

      /* Show step numbers in introduction? */
      showStepNumbers: false,

      /* Let user use keyboard to navigate the tour? */
      keyboardNavigation: true,

      /* Show tour control buttons? */
      showButtons: true,

      /* Show tour bullets? */
      showBullets: true,

      /* Show tour progress? */
      showProgress: false,

      /* Scroll to highlighted element? */
      scrollToElement: true,

      /*
       * Should we scroll the tooltip or target element?
       *
       * Options are: &apos;element&apos; or &apos;tooltip&apos;
       */
      scrollTo: &quot;element&quot;,

      /* Padding to add after scrolling when element is not in the viewport (in pixels) */
      scrollPadding: 30,

      /* Set the overlay opacity */
      overlayOpacity: 0.5,

      /* To determine the tooltip position automatically based on the window.width/height */
      autoPosition: true,

      /* Precedence of positions, when auto is enabled */
      positionPrecedence: [&quot;bottom&quot;, &quot;top&quot;, &quot;right&quot;, &quot;left&quot;],

      /* Disable an interaction with element? */
      disableInteraction: false,

      /* Set how much padding to be used around helper element */
      helperElementPadding: 10,

      /* Default hint position */
      hintPosition: &quot;top-middle&quot;,

      /* Hint button label */
      hintButtonLabel: &quot;Got it&quot;,

      /* Adding animation to hints? */
      hintAnimation: true,

      /* additional classes to put on the buttons */
      buttonClass: &quot;introjs-button&quot;,

      /* additional classes to put on progress bar */
      progressBarAdditionalClass: false
    };
  }

  var introJs = function introJs(targetElm) {
    var instance;

    if (_typeof(targetElm) === &quot;object&quot;) {
      //Ok, create a new instance
      instance = new IntroJs(targetElm);
    } else if (typeof targetElm === &quot;string&quot;) {
      //select the target element with query selector
      var targetElement = document.querySelector(targetElm);

      if (targetElement) {
        instance = new IntroJs(targetElement);
      } else {
        throw new Error(&quot;There is no element with given selector.&quot;);
      }
    } else {
      instance = new IntroJs(document.body);
    } // add instance to list of _instances
    // passing group to stamp to increment
    // from 0 onward somewhat reliably


    introJs.instances[stamp(instance, &quot;introjs-instance&quot;)] = instance;
    return instance;
  };
  /**
   * Current IntroJs version
   *
   * @property version
   * @type String
   */


  introJs.version = version$1;
  /**
   * key-val object helper for introJs instances
   *
   * @property instances
   * @type Object
   */

  introJs.instances = {}; //Prototype

  introJs.fn = IntroJs.prototype = {
    clone: function clone() {
      return new IntroJs(this);
    },
    setOption: function setOption(option, value) {
      this._options[option] = value;
      return this;
    },
    setOptions: function setOptions(options) {
      this._options = mergeOptions(this._options, options);
      return this;
    },
    start: function start(group) {
      introForElement.call(this, this._targetElement, group);
      return this;
    },
    goToStep: function goToStep$1(step) {
      goToStep.call(this, step);

      return this;
    },
    addStep: function addStep(options) {
      if (!this._options.steps) {
        this._options.steps = [];
      }

      this._options.steps.push(options);

      return this;
    },
    addSteps: function addSteps(steps) {
      if (!steps.length) return;

      for (var index = 0; index &lt; steps.length; index++) {
        this.addStep(steps[index]);
      }

      return this;
    },
    goToStepNumber: function goToStepNumber$1(step) {
      goToStepNumber.call(this, step);

      return this;
    },
    nextStep: function nextStep$1() {
      nextStep.call(this);

      return this;
    },
    previousStep: function previousStep$1() {
      previousStep.call(this);

      return this;
    },
    currentStep: function currentStep$1() {
      return currentStep.call(this);
    },
    exit: function exit(force) {
      exitIntro.call(this, this._targetElement, force);
      return this;
    },
    refresh: function refresh$1() {
      refresh.call(this);

      return this;
    },
    onbeforechange: function onbeforechange(providedCallback) {
      if (typeof providedCallback === &quot;function&quot;) {
        this._introBeforeChangeCallback = providedCallback;
      } else {
        throw new Error(&quot;Provided callback for onbeforechange was not a function&quot;);
      }

      return this;
    },
    onchange: function onchange(providedCallback) {
      if (typeof providedCallback === &quot;function&quot;) {
        this._introChangeCallback = providedCallback;
      } else {
        throw new Error(&quot;Provided callback for onchange was not a function.&quot;);
      }

      return this;
    },
    onafterchange: function onafterchange(providedCallback) {
      if (typeof providedCallback === &quot;function&quot;) {
        this._introAfterChangeCallback = providedCallback;
      } else {
        throw new Error(&quot;Provided callback for onafterchange was not a function&quot;);
      }

      return this;
    },
    oncomplete: function oncomplete(providedCallback) {
      if (typeof providedCallback === &quot;function&quot;) {
        this._introCompleteCallback = providedCallback;
      } else {
        throw new Error(&quot;Provided callback for oncomplete was not a function.&quot;);
      }

      return this;
    },
    onhintsadded: function onhintsadded(providedCallback) {
      if (typeof providedCallback === &quot;function&quot;) {
        this._hintsAddedCallback = providedCallback;
      } else {
        throw new Error(&quot;Provided callback for onhintsadded was not a function.&quot;);
      }

      return this;
    },
    onhintclick: function onhintclick(providedCallback) {
      if (typeof providedCallback === &quot;function&quot;) {
        this._hintClickCallback = providedCallback;
      } else {
        throw new Error(&quot;Provided callback for onhintclick was not a function.&quot;);
      }

      return this;
    },
    onhintclose: function onhintclose(providedCallback) {
      if (typeof providedCallback === &quot;function&quot;) {
        this._hintCloseCallback = providedCallback;
      } else {
        throw new Error(&quot;Provided callback for onhintclose was not a function.&quot;);
      }

      return this;
    },
    onexit: function onexit(providedCallback) {
      if (typeof providedCallback === &quot;function&quot;) {
        this._introExitCallback = providedCallback;
      } else {
        throw new Error(&quot;Provided callback for onexit was not a function.&quot;);
      }

      return this;
    },
    onskip: function onskip(providedCallback) {
      if (typeof providedCallback === &quot;function&quot;) {
        this._introSkipCallback = providedCallback;
      } else {
        throw new Error(&quot;Provided callback for onskip was not a function.&quot;);
      }

      return this;
    },
    onbeforeexit: function onbeforeexit(providedCallback) {
      if (typeof providedCallback === &quot;function&quot;) {
        this._introBeforeExitCallback = providedCallback;
      } else {
        throw new Error(&quot;Provided callback for onbeforeexit was not a function.&quot;);
      }

      return this;
    },
    addHints: function addHints() {
      populateHints.call(this, this._targetElement);
      return this;
    },
    hideHint: function hideHint$1(stepId) {
      hideHint.call(this, stepId);

      return this;
    },
    hideHints: function hideHints$1() {
      hideHints.call(this);

      return this;
    },
    showHint: function showHint$1(stepId) {
      showHint.call(this, stepId);

      return this;
    },
    showHints: function showHints$1() {
      showHints.call(this);

      return this;
    },
    removeHints: function removeHints$1() {
      removeHints.call(this);

      return this;
    },
    removeHint: function removeHint$1(stepId) {
      removeHint().call(this, stepId);

      return this;
    },
    showHintDialog: function showHintDialog$1(stepId) {
      showHintDialog.call(this, stepId);

      return this;
    }
  };

  return introJs;

})));
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
